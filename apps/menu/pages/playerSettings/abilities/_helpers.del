import '../../../../../libs/menu/components/text.del';
import '../../../../../libs/menu/components/toggle.del';
import '../../../../../libs/menu/components/numberInput.del';
import '../../../../../libs/menu/components/carousel.del';
import '../../../../../libs/utils/string.formatters.del';
import '../../../_variables.del';

playervar Button selectedButton;
// its kinda buggy when definied in the function
playervar Player[] filteredPlayers = [];
playervar Button[] pageAbilitiesEnabled = allButtons;
playervar Button[] pageAbilitiesInfiniteAmmo = [];
playervar Button[] pageAbilitiesNoCooldown = [];
playervar Button[] pageAbilitiesInfiniteCharge = [];
playervar Button[] pageAbilitiesInfiniteResource = [];
playervar Button[] pageAbilitiesKeepHoldingButton = [];
playervar Button[] pageAbilitiesKeepSpammingButton = [];

String PAGE_ABILITIES_WARNING_BROKEN: "Due to Workshop bugs, some settings might not work correctly for some heroes";

String PageAbilitiesInfo(Player player, Button button): 
  $"Enabled: {BooleanFormatter(player.pageAbilitiesEnabled.Contains(button))}\n" +
  $"Button held: {BooleanFormatter(player.buttonsHeld.Contains(button))}\n";

Carousel PageAbilitiesCarousel(in String text, in Button ability) {
  Carousel item! = new Carousel(
    text: text,
    options: ['off', 'hold', 'spam'],
    defaultValue: 
      selectedPlayers[0].pageAbilitiesKeepHoldingButton.Contains(ability) ? 'hold' :
      selectedPlayers[0].pageAbilitiesKeepSpammingButton.Contains(ability) ? 'spam' :
      'off'
  );

  item.onChange = (value, it) => {
    filteredPlayers = selectedPlayers.FilteredArray((i) => i != EventPlayer());

    foreach(Player pl! in filteredPlayers) {
      pl.pageAbilitiesKeepSpammingButton.ModRemoveByValue(ability);
      pl.pageAbilitiesKeepHoldingButton.ModRemoveByValue(ability);
      StopHoldingButton(pl, ability);
      
      if(it.value == 'hold') {
        pl.pageAbilitiesKeepHoldingButton.ModAppend(ability);
        StartHoldingButton(pl, ability);
      } else if(it.value == 'spam') {
        pl.pageAbilitiesKeepSpammingButton.ModAppend(ability);
      }
    }
  };

  return item;
}

void PageAbilitiesRuleGenerator(String title!, Button ability!, Button buttonApply!) "PageAbilitiesRuleGenerator" {
  selectedButton = ability;

  Description desc: { text: PAGE_ABILITIES_WARNING_BROKEN, color: Color.Orange, ..Description.BASE };

  menuState.CreatePage(title, PageAbilitiesMenuItemsGenerator(ability, buttonApply), [desc]);
}

NumberInput PageAbilitiesNumberInputGenerator(Button ability!, Button buttonApply!, String text!, String unit! = null, Number value!, ((Number) => void) onApply!) "PageAbilitiesNumberInputGenerator" {
  NumberInput numberInput! = new NumberInput(
    menuState: menuState, 
    text: text,
    defaultValue: value,
    integralLength: 5,
    unit: unit
  );
  numberInput.onButtonDown = (button, it) => {
    if(buttonsHeld == [buttonApply])
      onApply((<NumberInput>it).value);
  };
  numberInput.AddDescription($"Press {ButtonFormatterSingle(buttonApply)}â€‹ to apply");

  return numberInput;
}

Toggle PageAbilitiesToggleGenerator(String text!, Number defaultChecked!, ((Boolean) => void) onApply!) "PageAbilitiesToggleGenerator" {
  Toggle toggle! = new Toggle(
    text: text,
    defaultChecked: defaultChecked
  );
  toggle.onChange = (checked, it) => {
    onApply(checked);
  };

  return toggle;
}

Component[] PageAbilitiesMenuItemsGenerator(Button ability!, Button buttonApply!) "PageAbilitiesMenuItemsGenerator" {
  Component[] list = [];

  // enabled
  // since we can't disable Interact button...
  if(ability != Button.Interact) {
    list += PageAbilitiesToggleGenerator(
      text: 'Enabled',
      defaultChecked: selectedPlayers[0].pageAbilitiesEnabled.Contains(ability),
      onApply: (value) => {
        foreach(Player pl! in selectedPlayers) {
          if(value)
            pl.pageAbilitiesEnabled.ModAppend(ability);
          else
            pl.pageAbilitiesEnabled.ModRemoveByValue(ability);

          if(ability == Button.PrimaryFire) SetPrimaryFireEnabled(pl, value);
          else if(ability == Button.SecondaryFire) SetSecondaryFireEnabled(pl, value);
          else if(ability == Button.Ability1) SetAbility1Enabled(pl, value);
          else if(ability == Button.Ability2) SetAbility2Enabled(pl, value);
          else if(ability == Button.Ultimate) SetUltimateAbilityEnabled(pl, value);
          else if(ability == Button.Reload) SetReloadEnabled(pl, value);
          else if(ability == Button.Melee) SetMeleeEnabled(pl, value);
          else if(ability == Button.Jump) SetJumpEnabled(pl, value);
          else SetCrouchEnabled(pl, value);
        }
      }
    );

    list += new Text();
  }

  // use
  Carousel use = PageAbilitiesCarousel('Use', ability);

  if(ability == Button.Ultimate) {
    list += PageAbilitiesNumberInputGenerator(
      ability: ability,
      buttonApply: buttonApply,
      text: 'Charge',
      unit: '%',
      value: UltimateChargePercent(selectedPlayers[0]),
      onApply: (value) => SetUltimateCharge(selectedPlayers, value)
    );

    list += new Text();

    list += PageAbilitiesToggleGenerator(
      text: 'Infinite Charge',
      defaultChecked: selectedPlayers[0].pageAbilitiesInfiniteCharge.Contains(ability),
      onApply: (value) => {
        foreach(Player pl! in selectedPlayers) {
          if(value)
            pl.pageAbilitiesInfiniteCharge.ModAppend(ability);
          else
            pl.pageAbilitiesInfiniteCharge.ModRemoveByValue(ability);
        }
      }
    );

    list += new Text();
    list += use;

    return list;
  }

  if(ability == Button.PrimaryFire || ability == Button.SecondaryFire) {
    Number clip! = ability == Button.SecondaryFire ? 1 : 0;

    list += PageAbilitiesNumberInputGenerator(
      ability: ability,
      buttonApply: buttonApply,
      text: 'Ammo',
      value: Ammo(selectedPlayers[0], clip),
      onApply: (value) => SetAmmo(selectedPlayers, clip, value)
    );
    list += PageAbilitiesNumberInputGenerator(
      ability: ability,
      buttonApply: buttonApply,
      text: 'Max Ammo',
      value: MaxAmmo(selectedPlayers[0], clip),
      onApply: (value) => SetMaxAmmo(selectedPlayers, clip, value)
    );
  }

  list += PageAbilitiesNumberInputGenerator(
    ability: ability,
    buttonApply: buttonApply,
    text: 'Cooldown',
    unit: ' sec',
    value: AbilityCooldown(selectedPlayers[0], ability),
    onApply: (value) => SetAbilityCooldown(selectedPlayers, ability, value)
  );

  list += PageAbilitiesNumberInputGenerator(
    ability: ability,
    buttonApply: buttonApply,
    text: 'Charge',
    value: AbilityCharge(selectedPlayers[0], ability),
    onApply: (value) => SetAbilityCharge(selectedPlayers, ability, value)
  );

  list += PageAbilitiesNumberInputGenerator(
    ability: ability,
    buttonApply: buttonApply,
    text: 'Resource',
    unit: '%',
    value: AbilityResource(selectedPlayers[0], ability),
    onApply: (value) => SetAbilityResource(selectedPlayers, ability, value)
  );

  list += new Text();

  // infinite
  if(ability == Button.PrimaryFire || ability == Button.SecondaryFire) {
    list += PageAbilitiesToggleGenerator(
      text: 'Infinite Ammo',
      defaultChecked: selectedPlayers[0].pageAbilitiesInfiniteAmmo.Contains(ability),
      onApply: (value) => {
        foreach(Player pl! in selectedPlayers) {
          if(value)
            pl.pageAbilitiesInfiniteAmmo.ModAppend(ability);
          else
            pl.pageAbilitiesInfiniteAmmo.ModRemoveByValue(ability);
        }
      }
    );
  }

  list += PageAbilitiesToggleGenerator(
    text: 'No Cooldown',
    defaultChecked: selectedPlayers[0].pageAbilitiesNoCooldown.Contains(ability),
    onApply: (value) => {
      foreach(Player pl! in selectedPlayers) {
        if(value)
          pl.pageAbilitiesNoCooldown.ModAppend(ability);
        else
          pl.pageAbilitiesNoCooldown.ModRemoveByValue(ability);
      }
    }
  );

  list += PageAbilitiesToggleGenerator(
    text: 'Infinite Charge',
    defaultChecked: selectedPlayers[0].pageAbilitiesInfiniteCharge.Contains(ability),
    onApply: (value) => {
      foreach(Player pl! in selectedPlayers) {
        if(value)
          pl.pageAbilitiesInfiniteCharge.ModAppend(ability);
        else
          pl.pageAbilitiesInfiniteCharge.ModRemoveByValue(ability);
      }
    }
  );

  list += PageAbilitiesToggleGenerator(
    text: 'Infinite Resource',
    defaultChecked: selectedPlayers[0].pageAbilitiesInfiniteResource.Contains(ability),
    onApply: (value) => {
      foreach(Player pl! in selectedPlayers) {
        if(value)
          pl.pageAbilitiesInfiniteResource.ModAppend(ability);
        else
          pl.pageAbilitiesInfiniteResource.ModRemoveByValue(ability);
      }
    }
  );

  list += new Text();
  list += use;

  return list;
}
