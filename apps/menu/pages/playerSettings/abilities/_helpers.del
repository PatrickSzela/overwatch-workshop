import '../../../../../libs/menu/components/text.del';
import '../../../../../libs/menu/components/toggle.del';
import '../../../../../libs/menu/components/numberInput.del';
import '../../../../../libs/utils/string.formatters.del';
import '../../../_variables.del';

Button PAGE_ABILITIES_BUTTON_HOLD: Button.Reload;
Button PAGE_ABILITIES_BUTTON_TOGGLE_HOLDING: Button.Interact;
Button PAGE_ABILITIES_BUTTON_TOGGLE_PRESSING: Button.Melee;

playervar Button selectedButton;
// its kinda buggy when definied in the function
playervar Player[] filteredPlayers = [];
playervar Boolean[] pageAbilitiesEnabled = [true, true, true, true, true, true, true, true, true, true];
// apparently IsButtonHeld doesn't work for players other than EventPlayer() on client side...
playervar Boolean[] pageAbilitiesInfiniteAmmo = [];
playervar Boolean[] pageAbilitiesNoCooldown = [];
playervar Boolean[] pageAbilitiesInfiniteCharge = [];
playervar Boolean[] pageAbilitiesInfiniteResource = [];
playervar Boolean[] pageAbilitiesKeepPressingButton = [];

String PAGE_ABILITIES_WARNING_BROKEN: "Due to Workshop bugs, some settings might not work correctly for some heroes";

String PageAbilitiesInfo(Player player, Button button): 
  $"Enabled: {BooleanFormatter(player.pageAbilitiesEnabled[allButtons.IndexOf(button)])}\n" +
  $"Button held: {BooleanFormatter(player.buttonsHeld.Contains(EvaluateOnce(button)))}\n";

void PageAbilitiesHoldButtonMenuItemEnhancer(ref Component item, in Button ability) {
  item.onButtonDown = (_button, it) => {
    filteredPlayers = selectedPlayers.FilteredArray((i) => i != EventPlayer());

    if(buttonsHeld == [PAGE_ABILITIES_BUTTON_HOLD]) {
      StartHoldingButton(filteredPlayers, ability);        
    } else if(buttonsHeld == [PAGE_ABILITIES_BUTTON_TOGGLE_HOLDING]) {
      foreach(Player pl in filteredPlayers)
        pl.pageAbilitiesKeepPressingButton[allButtons.IndexOf(ability)] = false;

      if(filteredPlayers[0].IsButtonHeld(ability)) {
        StopHoldingButton(filteredPlayers, ability);
      } else {
        StartHoldingButton(filteredPlayers, ability);
      }
    } else if(buttonsHeld == [PAGE_ABILITIES_BUTTON_TOGGLE_PRESSING]) {
      foreach(Player pl in filteredPlayers) {
        pl.pageAbilitiesKeepPressingButton[allButtons.IndexOf(ability)] = !pl.pageAbilitiesKeepPressingButton[allButtons.IndexOf(ability)];

        if(!pl.pageAbilitiesKeepPressingButton[allButtons.IndexOf(ability)]) {
          StopHoldingButton(pl, ability);
        }
      }
    }
  };
  item.onButtonUp = (_button, it) => {
    filteredPlayers = selectedPlayers.FilteredArray((i) => i != EventPlayer());

    if(_button == PAGE_ABILITIES_BUTTON_HOLD && buttonsHeld == []) {
      StopHoldingButton(selectedPlayers, EvaluateOnce(ability));
    }
  };
  
  item.AddDescription($"Hold {ButtonFormatterSingle(PAGE_ABILITIES_BUTTON_HOLD)}​ to force players to hold the button");
  item.AddDescription($"Press {ButtonFormatterSingle(PAGE_ABILITIES_BUTTON_TOGGLE_HOLDING)}​ to toggle forced button holding");
  item.AddDescription($"Press {ButtonFormatterSingle(PAGE_ABILITIES_BUTTON_TOGGLE_PRESSING)}​ to toggle forced button spamming (hold for 1 sec, release, repeat)");
}
void PageAbilitiesRuleGenerator(String title!, Button ability!, Button buttonApply!) "PageAbilitiesRuleGenerator" {
  selectedButton = ability;

  Description desc: { text: PAGE_ABILITIES_WARNING_BROKEN, color: Color.Orange, ..Description.BASE };

  menuState.CreatePage(title, PageAbilitiesMenuItemsGenerator(ability, buttonApply), [desc]);
}

Component PageAbilitiesSpinnerGenerator(Button ability!, Button buttonApply!, String text!, String unit! = null, Number value!, ((Number) => void) onApply!) "PageAbilitiesSpinnerGenerator" {
  NumberInput numberInput! = new NumberInput(
    menuState: menuState, 
    text: text,
    defaultValue: value,
    integralLength: 5,
    unit: unit
  );
  numberInput.onButtonDown = (button, it) => {
    if(buttonsHeld == [buttonApply])
      onApply((<NumberInput>it).value);
  };
  numberInput.AddDescription($"Press {ButtonFormatterSingle(buttonApply)}​ to apply");

  return numberInput;
}

Component PageAbilitiesToggleGenerator(String text!, Number defaultChecked!, ((Boolean) => void) onApply!) "PageAbilitiesToggleGenerator" {
  Toggle toggle! = new Toggle(
    text: text,
    defaultChecked: defaultChecked
  );
  toggle.onChange = (checked, it) => {
    onApply(checked);
  };

  return toggle;
}

Component[] PageAbilitiesMenuItemsGenerator(Button ability!, Button buttonApply!) "PageAbilitiesMenuItemsGenerator" {
  Component[] list = [];

  // enabled
  // since we can't disable Interact button...
  if(ability != Button.Interact) {
    list += PageAbilitiesToggleGenerator(
      text: 'Enabled',
      defaultChecked: selectedPlayers[0].pageAbilitiesEnabled[allButtons.IndexOf(ability)],
      onApply: (value) => {
        foreach(Player pl! in selectedPlayers) {
          pl.pageAbilitiesEnabled[allButtons.IndexOf(ability)] = value;
          
          if(ability == Button.PrimaryFire) SetPrimaryFireEnabled(pl, value);
          else if(ability == Button.SecondaryFire) SetSecondaryFireEnabled(pl, value);
          else if(ability == Button.Ability1) SetAbility1Enabled(pl, value);
          else if(ability == Button.Ability2) SetAbility2Enabled(pl, value);
          else if(ability == Button.Ultimate) SetUltimateAbilityEnabled(pl, value);
          else if(ability == Button.Reload) SetReloadEnabled(pl, value);
          else if(ability == Button.Melee) SetMeleeEnabled(pl, value);
          else if(ability == Button.Jump) SetJumpEnabled(pl, value);
          else SetCrouchEnabled(pl, value);
        }
      }
    );

    list += new Text();
  }

  // use
  Component use! = new Component('Use');
  use.onButtonDown = (button, it) => {
    if(buttonsHeld == [buttonApply])
      PressButton(selectedPlayers.FilteredArray((i) => i != EventPlayer()), ability);
  };
  PageAbilitiesHoldButtonMenuItemEnhancer(use, ability);

  if(ability == Button.Ultimate) {
    list += PageAbilitiesSpinnerGenerator(
      ability: ability,
      buttonApply: buttonApply,
      text: 'Charge',
      unit: '%',
      value: UltimateChargePercent(selectedPlayers[0]),
      onApply: (value) => SetUltimateCharge(selectedPlayers, value)
    );

    list += new Text();

    list += PageAbilitiesToggleGenerator(
      text: 'Infinite Charge',
      defaultChecked: selectedPlayers[0].pageAbilitiesInfiniteCharge[allButtons.IndexOf(ability)],
      onApply: (value) => {
        foreach(Player pl! in selectedPlayers)
          pl.pageAbilitiesInfiniteCharge[allButtons.IndexOf(ability)] = value;
      }
    );

    list += new Text();
    list += use;

    return list;
  }

  if(ability == Button.PrimaryFire || ability == Button.SecondaryFire) {
    Number clip! = ability == Button.SecondaryFire ? 1 : 0;

    list += PageAbilitiesSpinnerGenerator(
      ability: ability,
      buttonApply: buttonApply,
      text: 'Ammo',
      value: Ammo(selectedPlayers[0], clip),
      onApply: (value) => SetAmmo(selectedPlayers, clip, value)
    );
    list += PageAbilitiesSpinnerGenerator(
      ability: ability,
      buttonApply: buttonApply,
      text: 'Max Ammo',
      value: MaxAmmo(selectedPlayers[0], clip),
      onApply: (value) => SetMaxAmmo(selectedPlayers, clip, value)
    );
  }

  list += PageAbilitiesSpinnerGenerator(
    ability: ability,
    buttonApply: buttonApply,
    text: 'Cooldown',
    unit: ' sec',
    value: AbilityCooldown(selectedPlayers[0], ability),
    onApply: (value) => SetAbilityCooldown(selectedPlayers, ability, value)
  );

  list += PageAbilitiesSpinnerGenerator(
    ability: ability,
    buttonApply: buttonApply,
    text: 'Charge',
    value: AbilityCharge(selectedPlayers[0], ability),
    onApply: (value) => SetAbilityCharge(selectedPlayers, ability, value)
  );

  list += PageAbilitiesSpinnerGenerator(
    ability: ability,
    buttonApply: buttonApply,
    text: 'Resource',
    unit: '%',
    value: AbilityResource(selectedPlayers[0], ability),
    onApply: (value) => SetAbilityResource(selectedPlayers, ability, value)
  );

  list += new Text();

  // infinite
  if(ability == Button.PrimaryFire || ability == Button.SecondaryFire) {
    list += PageAbilitiesToggleGenerator(
      text: 'Infinite Ammo',
      defaultChecked: selectedPlayers[0].pageAbilitiesInfiniteAmmo[allButtons.IndexOf(ability)],
      onApply: (value) => {
        foreach(Player pl! in selectedPlayers)
          pl.pageAbilitiesInfiniteAmmo[allButtons.IndexOf(ability)] = value;
      }
    );
  }

  list += PageAbilitiesToggleGenerator(
    text: 'No Cooldown',
    defaultChecked: selectedPlayers[0].pageAbilitiesNoCooldown[allButtons.IndexOf(ability)],
    onApply: (value) => {
      foreach(Player pl! in selectedPlayers)
        pl.pageAbilitiesNoCooldown[allButtons.IndexOf(ability)] = value;
    }
  );

  list += PageAbilitiesToggleGenerator(
    text: 'Infinite Charge',
    defaultChecked: selectedPlayers[0].pageAbilitiesInfiniteCharge[allButtons.IndexOf(ability)],
    onApply: (value) => {
      foreach(Player pl! in selectedPlayers)
        pl.pageAbilitiesInfiniteCharge[allButtons.IndexOf(ability)] = value;
    }
  );

  list += PageAbilitiesToggleGenerator(
    text: 'Infinite Resource',
    defaultChecked: selectedPlayers[0].pageAbilitiesInfiniteResource[allButtons.IndexOf(ability)],
    onApply: (value) => {
      foreach(Player pl! in selectedPlayers)
        pl.pageAbilitiesInfiniteResource[allButtons.IndexOf(ability)] = value;
    }
  );

  list += new Text();
  list += use;

  return list;
}
