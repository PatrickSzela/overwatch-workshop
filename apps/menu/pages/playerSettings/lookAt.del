import '../../../../libs/menu/components/radio.del';
import '../../../../libs/menu/components/carousel.del';
import '../../../../libs/utils/string.formatters.del';
import '../../../../libs/utils/player.sortedAllPlayers.del';
import '../../../../libs/utils/player.del';
import '../../_variables.del';

String PAGE_LOOK_AT_ID: 'lookAt';
String PAGE_LOOK_AT_NAME: 'Look At';

enum PageLookAtChoice {
  POSITION = 'Position',
  OBJECTIVE = 'Objective',
  PLAYER = 'Player',
  LOOKING_PLAYER = 'Looking position of'
}

enum PageLookAtVariant {
  ONCE = 'Once',
  OVER_TIME = 'Over time',
  STOP = 'Stop'
}

single struct PageLookAtProps {
  public PageLookAtChoice choice;
  public Any value;
  public PageLookAtVariant variant;
  public Boolean forceRefresh;

  public static PageLookAtProps BASE:
    {choice: PageLookAtChoice.POSITION, value: Vector.Zero, variant: PageLookAtVariant.STOP, forceRefresh: false};
}

Action ACTION_LookAtCustom(Player[] players, PageLookAtProps props): 
  Action.New($"Look at({props.variant}, {props.choice}, {props.value}, [{players}])", () => {
    players.pageLookAtPlayerSettings = props;
  });

playervar PageLookAtProps pageLookAtProps;
playervar PageLookAtProps pageLookAtPlayerSettings = PageLookAtProps.BASE;

Vector PageLookAtRayCast(Player player):
  RayCastHitPosition(EyePosition(player), EyePosition(player) + FacingDirectionOf(player) * 100, AllPlayers(), player, true);

Component[] PageLookAtItems() {
  // position
  ComponentWithValue position = new ComponentWithValue(<String>PageLookAtChoice.POSITION, Vector.Zero);
  position.AddDescription(Description.New(PickPosition.CHANGE_DISTANCE_DESCRIPTION(BUTTON_INCREASE, BUTTON_DECREASE)));
  position.onEnter = (it) => {
    pickPosition.Enable(Color.Red);
  };
  position.onLeave = (it) => {
    pickPosition.Disable();
  };
  position.onButtonDown = (button, it) => {
    if(buttonsHeld == [BUTTON_INCREASE])
      pickPosition.StartChangingRaycaseDistance(0.1);
    else if(buttonsHeld == [BUTTON_DECREASE])
      pickPosition.StartChangingRaycaseDistance(-0.1);
  };
  position.onButtonUp = (button, it) => {
    pickPosition.StopChangingRaycaseDistance();
  };
  position.SetPrimaryAction('Choose the position', (it) => {
    (<ComponentWithValue>it).SetValue(pickPosition.position);
    pageLookAtProps = { choice: PageLookAtChoice.POSITION, value: pickPosition.position, ..pageLookAtProps };
  });

  Radio positionRadio = new Radio(menuState, <String>PageLookAtChoice.POSITION, PAGE_LOOK_AT_NAME);
  positionRadio.child = position;

  // objective, player, looking position of player
  Component[] carousels = [];

  foreach(PageLookAtChoice choice in [PageLookAtChoice.OBJECTIVE, PageLookAtChoice.PLAYER, PageLookAtChoice.LOOKING_PLAYER]) {
    Carousel carousel = new Carousel(
      text: <String>choice,
      options: 
        choice == PageLookAtChoice.OBJECTIVE ? [-2, -1, 0, 1, 2, 3, 4] :
        sortedPlayers,
      defaultValue: choice == PageLookAtChoice.OBJECTIVE ? -1 : 0
    );
    carousel.valueFormatter = choice == PageLookAtChoice.OBJECTIVE ? 
      (it) => ObjectiveFormatter(it.value) : 
      (it) => PlayerWithHeroIconTeamSlotFormatter(it.value);
    carousel.onChange = (value, it) => {
      pageLookAtProps = { choice: choice, value: value, ..pageLookAtProps };
    };
    carousel.onPrimaryAction = (it) => {
      pageLookAtProps = { choice: choice, value: (<Carousel>it).value, ..pageLookAtProps };
    };

    Radio radio = new Radio(menuState, <String>choice, PAGE_LOOK_AT_NAME);
    radio.child = carousel;

    carousels += radio;
  }

  // apply
  Carousel apply = new Carousel('Apply', [PageLookAtVariant.ONCE, PageLookAtVariant.OVER_TIME, PageLookAtVariant.STOP]);
  apply.SetPrimaryAction('Apply', (it) => {
    pageLookAtProps = { variant: (<Carousel>it).value, forceRefresh: true, ..pageLookAtProps };
    selectedPlayers.pageLookAtPlayerSettings = pageLookAtProps;
  });
  apply.SetTertiaryAction('Add to timeline', (it) => {
    pageLookAtProps = { variant: (<Carousel>it).value, forceRefresh: true, ..pageLookAtProps };
    Timeline.AddAction(timeline, ACTION_LookAtCustom(selectedPlayers, pageLookAtProps));
  });

  return [<Component>positionRadio] + carousels + [new Text(), apply];
}

rule: 'Player Settings/Look At'
Event.OngoingPlayer
if(menuState.pageId == PAGE_LOOK_AT_ID)
{
  pageLookAtProps = PageLookAtProps.BASE;

  menuState.CreatePage(
    title: PAGE_LOOK_AT_NAME, 
    items: PageLookAtItems()
  );
}

rule: 'Player Settings/Look At: Create Sphere'
Event.OngoingPlayer
if(menuState.isOpen)
if(menuState.pageId == PAGE_LOOK_AT_ID)
{
  foreach(Player p! in AllPlayers()) {
    if(p == EventPlayer()) continue;

    pickPosition.CreateAdditionalSphere(
      color: Color.Green,
      position: PageLookAtRayCast(EvaluateOnce(p)),
      text: $"{EvaluateOnce(p)}'s look position:\n{PickPosition.RayCast(EvaluateOnce(p))}",
      lineEnd: EvaluateOnce(p).EyePosition()
    );

    Wait(0.05);
  }

  WaitUntil(menuState.pageId != PAGE_LOOK_AT_ID || !menuState.isOpen, 99999);

  pickPosition.DestroyAdditionalSpheres();
}

rule: 'Look At: Start/Stop looking at'
Event.OngoingPlayer
{
  WaitUntil(pageLookAtPlayerSettings != EvaluateOnce(pageLookAtPlayerSettings), 99999);

  pageLookAtPlayerSettings.forceRefresh = false;

  StopFacing(EventPlayer());

  Any value: pageLookAtPlayerSettings.value;
  PageLookAtChoice choice: pageLookAtPlayerSettings.choice;
  Vector pos: 
    choice == PageLookAtChoice.OBJECTIVE ? 
      value == -2 ? PayloadPosition() : ObjectivePosition(value == -1 ? ObjectiveIndex() : value) :
    choice == PageLookAtChoice.PLAYER ? EyePosition(value) : 
    choice == PageLookAtChoice.LOOKING_PLAYER ? PageLookAtRayCast(value) :
    value;

  if(pageLookAtPlayerSettings.variant == PageLookAtVariant.ONCE) {
    SetFacing(EventPlayer(), GetDirectionFromPlayerEyes(EventPlayer(), pos), Relative.ToWorld);
  } else if(pageLookAtPlayerSettings.variant == PageLookAtVariant.OVER_TIME) {
    StartFacing(EventPlayer(), GetDirectionFromPlayerEyes(EventPlayer(), pos), 500, Relative.ToWorld, FacingRev.DirectionAndTurnRate);
  }

  Loop();
}
