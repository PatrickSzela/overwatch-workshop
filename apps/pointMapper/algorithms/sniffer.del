import "../_variables.del";
import "../_helpers.del";
import "../../../libs/utils/bigArray.del";
import "../../../libs/utils/vector.del";
import "../../../libs/utils/number.del";

enum StepSniffer {
  Nothing = -1,
  Mapping,
  Simplifying,
  Drawing,
  Cleaning
}

globalvar StepSniffer stepSniffer = StepSniffer.Nothing;
globalvar Vector[] order = [
  Vector( 0,  0,  1), 
  Vector(-1,  0,  1), 
  Vector(-1,  0,  0), 
  Vector(-1,  0, -1), 
  Vector( 0,  0, -1), 
  Vector( 1,  0, -1), 
  Vector( 1,  0,  0),
  Vector( 1,  0,  1)
];
globalvar Player[] mainDummies = [];

playervar Player[] helperDummies = [];
playervar Vector[] dummyOrder = order;
playervar Vector[] cache = [];
playervar Any arrow = null;

rule: '[Sniffer] Step 0: Initialize'
if(step == Step.WorkingSniffer)
if(stepSniffer == StepSniffer.Nothing)
{
  SmallMessage(AllPlayers(), "[Sniffer] Preparing");

  center = CurrentObjectivePosition() + (Offsets.Get(CurrentMap())[ObjectiveIndex()] || Vector.Zero);

  center = Vector(
    RoundToInteger(center.X * 100) / 100, 
    RoundToInteger(center.Y * 100) / 100, 
    RoundToInteger(center.Z * 100) / 100
  );

  // generate dummies
  mainDummies = AddDummies(2);

  for(Number i! = 0; i < mainDummies.Length; i++) {
    Player dummy: mainDummies[i];

    dummy.dummyOrder = !i ? order : ShiftAndPush(Reverse(order), -1);

    dummy.arrow = CreateInWorldText(AllPlayers(), "â†“", UpdateEveryFrame(EvaluateOnce(dummy).EyePosition() + Up() * scale * 10), 3, Clipping.DoNotClip, InworldTextRev.VisibleToAndPosition, Color.Team1);

    Wait(0.1);

    SetFacing(dummy, dummy.dummyOrder[0], Relative.ToWorld);

    dummy.helperDummies = AddDummies(order.Length);

    for(Number x! = 0; x < dummy.helperDummies.Length; x++) {
      Player helperDummy: dummy.helperDummies[x];
      AttachPlayers(helperDummy, dummy, dummy.dummyOrder[x] * scale);
      SetFacing(helperDummy, dummy.dummyOrder[0], Relative.ToWorld);
    }

    dummy.Teleport(center);
  }

  Wait(0.5);

  stepSniffer = StepSniffer.Mapping;
}

rule: '[Sniffer] Step 1: Mapping'
if(step == Step.WorkingSniffer)
if(stepSniffer == StepSniffer.Mapping)
{
  DisableInspectorRecording();

  while(stepSniffer == StepSniffer.Mapping) {
    for(Number a = 0; a < mainDummies.Length; a++) {
      Player mainDummy: mainDummies[a];

      if(mainDummy.finished)
        continue;

      if(mainDummy.points.Length > 1 && 
        mainDummies.IsTrueForAny((p) => 
          mainDummy.position.DistanceTo(p.points.First()) < 1.5 || 
          mainDummy.position.DistanceTo(p.position) < 1.5 &&
          p != mainDummy
        )
      ) {
        mainDummy.finished = true;
        continue;
      }

      Boolean[] obj = mainDummy.helperDummies.Map((p) => p.IsOnObjective());

      for(Number i = 0; i < mainDummy.helperDummies.Length; i++) {
        if((i == 0 ? !obj.Last && obj[0] : !obj[i - 1] && obj[i])) {
          if(i == 0) break;
          if(i == mainDummy.helperDummies.Length / 2) continue;

          // skip appending point if the bot that's going in the other direction might go further (King's Row)
          if(mainDummy.points.Length == 0 && obj.First) {}
          else {
            mainDummy.points.Append(mainDummy.position);
          }

          mainDummy.dummyOrder = ShiftAndPush(mainDummy.dummyOrder, i);
          mainDummy.helperDummies = ShiftAndPush(mainDummy.helperDummies, i);

          break;
        }
      }
      
      if(!mainDummy.finished) {
        mainDummy.position += mainDummy.dummyOrder[0];
        mainDummy.Teleport(center + mainDummy.position * scale);
      }
    }

    if(mainDummies.IsTrueForAll((e) => e.finished)) {
      Wait(0.1);

      // remove dummies
      foreach(Player[] dummy in mainDummies) {
        if(dummy != mainDummies[0])
          dummy.points.Reverse();

        MinWait();

        RemoveDummies(dummy.helperDummies);
        DestroyInWorldText(dummy.arrow);

        outline.ConcatBigArray(dummy.points);

        MinWait();
      }

      RemoveDummies(mainDummies);
      mainDummies = [];

      Wait(0.1);

      stepSniffer = StepSniffer.Simplifying;
    }

    Wait(ServerLoadAverage() > 100 ? 0.032 : 0.016);
  }

  EnableInspectorRecording();
}

rule: '[Sniffer] Step 2: Simplifying'
if(step == Step.WorkingSniffer)
if(stepSniffer == StepSniffer.Simplifying)
{
  SmallMessage(AllPlayers(), "[Sniffer] Simplifying");

  EnableInspectorRecording();
  LogToInspector($"Smoothing using Vector direction {outline.Length} points");
  DisableInspectorRecording();

  for(Number i = 0; i < 8; i++) {
    count = outline.Length;
    outline = SmoothenBetweenVectors(outline);

    EnableInspectorRecording();
    LogToInspector($"Pass {i} finished, length: {outline.Length}");
    DisableInspectorRecording();
    
    if(count - outline.Length <= 1)
      break;
  }

  Wait(0.5);

  EnableInspectorRecording();
  LogToInspector($"Smoothing using RDP {outline.Length} points");
  DisableInspectorRecording();

  outline = SmoothenRDP(outline, 1, true);

  Wait(0.5);

  EnableInspectorRecording();

  step = Step.Drawing;
  stepSniffer = StepSniffer.Nothing;
}
