import "variables.del";

enum StepCuber {
  Nothing = -1,
  FindindCenter,
  Mapping
}

enum FakeBoolean {
  False = 1,
  True = 2
}

globalvar StepCuber stepCuber = StepCuber.Nothing;
globalvar Number radius = 0;

playervar Vector offsetFromObjective = null;
playervar FakeBoolean[] wasOnObjective = [];
playervar FakeBoolean[] prevWasOnObjective = [];
playervar Vector prevPosition = null;

rule: '[Cuber] Step 0: Initialize'
if(step == Step.WorkingCuber)
if(stepCuber == StepCuber.Nothing)
{
  center = null;

  foreach(Player dummy in dummies.Slice(0, 6)) {
    dummy.offsetFromObjective = null;
    dummy.wasOnObjectiveAtLeastOnce = false;
    dummy.wasOnObjective = [];
    dummy.prevWasOnObjective = [];
    dummy.finished = false;

    dummy.Teleport(CurrentObjectivePosition());
  }

  Wait();

  stepCuber = StepCuber.FindindCenter;
}

rule: '[Cuber] Step 1: Find \'center\' for faster mapping'
if(step == Step.WorkingCuber)
if(stepCuber == StepCuber.FindindCenter)
{
  DisableInspectorRecording();

  while(stepCuber == StepCuber.FindindCenter) {
    for(Number i = 0; i < 6; i++) {
      Player dummy = dummies[i];

      if(!dummy.finished) {
        dummy.offsetFromObjective = dummy.Position() - CurrentObjectivePosition();
        dummy.Teleport(dummy.Position() + directions[i] * scale);
      }
    }
    
    Wait();

    for(Number i = 0; i < 6; i++) {
      if(dummies[i].IsOnObjective()) {
        dummies[i].wasOnObjectiveAtLeastOnce = true;
        dummies[i].finished = false;
      } else if(dummies[i].wasOnObjectiveAtLeastOnce) {
        dummies[i].finished = true;
      }
    }

    if(IsTrueForAll(dummies.Slice(0, 6), ArrayElement().finished)) {
      center = Vector(
        AbsoluteValue(dummies[0].offsetFromObjective.X) - AbsoluteValue(dummies[1].offsetFromObjective.X),
        AbsoluteValue(dummies[2].offsetFromObjective.Y) - AbsoluteValue(dummies[3].offsetFromObjective.Y),
        AbsoluteValue(dummies[4].offsetFromObjective.Z) - AbsoluteValue(dummies[5].offsetFromObjective.Z),
      );

      center += CurrentObjectivePosition();

      center = Vector(
        RoundToInteger(center.X * 100) / 100, 
        RoundToInteger(center.Y * 100) / 100, 
        RoundToInteger(center.Z * 100) / 100
      );

      SmallMessage(AllPlayers(), $"Center found: {center}");
      CreateEffect(AllPlayers(), Effect.Sphere, Color.Red, center, 0.25, EffectRev.None);

      stepCuber = StepCuber.Mapping;
    }
  }

  EnableInspectorRecording();
}

rule: '[Cuber] Step 2: Mapping'
if(step == Step.WorkingCuber)
if(stepCuber == StepCuber.Mapping)
{
  // TODO: why?
  radius = 2;

  // currently only 2D
  center = Vector(center.X, RoundToInteger(CurrentObjectivePosition().Y * 100) / 100 + 0.1, center.Z);

  for(Number i = 0; i < 8; i++) {
    dummies[i].wasOnObjectiveAtLeastOnce = false;
    dummies[i].finished = true;
  }

  DisableInspectorRecording();

  while(stepCuber == StepCuber.Mapping) {
    for(Number i = 0; i < 8; i++) {
      Player dummy = dummies[i];

      dummy.finished = true;
      dummy.prevWasOnObjective = dummy.wasOnObjective;
      dummy.wasOnObjective = [];
    }

    for(Number x = -1; x < radius + 1; x++) {
      for(Number i = 0; i < 8; i++) {
        Player dummy = dummies[i];

        dummy.position = Vector(
          directionsDiagonal[i].X * (i < 4 ? x : radius), 
          0, 
          directionsDiagonal[i].Z * (i >= 4 ? x : radius)
        );

        dummy.prevPosition = Vector(
          directionsDiagonal[i].X * (i < 4 ? x : (radius - 1)), 
          0, 
          directionsDiagonal[i].Z * (i >= 4 ? x : (radius - 1))
        );

        dummy.Teleport(center + dummy.position * scale);
      }

      // check whether player is on objective happens in next tick after teleporting
      Wait();

      for(Number i = 0; i < 8; i++) {
        Player dummy = dummies[i];

        if(!dummy.IsOnObjective()) {
          dummy.wasOnObjective[x] = FakeBoolean.False;

          if(dummy.prevWasOnObjective[x - 1] == FakeBoolean.True) {
            // fix random spheres showing up inside objective && do not add points if they exists in the perpendicular axis already
            if(x >= 0 && !IsTrueForAny(dummy.points, i < 4 ? (<Vector>ArrayElement()).X == dummy.prevPosition.X : (<Vector>ArrayElement()).Z == dummy.prevPosition.Z)) {
              dummy.points.Append(dummy.prevPosition);
              CreateEffect(AllPlayers(), Effect.Sphere, Color.Red, center + dummy.prevPosition * scale, scale / 2, EffectRev.None);
            }
          }
        } else {
          dummy.finished = false;
          dummy.wasOnObjective[x] = FakeBoolean.True;
          dummy.wasOnObjectiveAtLeastOnce = true;
        }
      }
    }

    if(IsTrueForAll(dummies.Slice(0, 8), ArrayElement().finished && ArrayElement().wasOnObjectiveAtLeastOnce)) {
      SmallMessage(AllPlayers(), "Finished");
      stepCuber = StepCuber.Nothing;
      step = Step.Nothing;
    }

    radius += 1;
  }

  EnableInspectorRecording();
}