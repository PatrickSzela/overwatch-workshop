import "variables.del";
import "../../libs/utils/bigArray.del";
import "../../libs/utils/vector.del";
import "../../libs/utils/number.del";

enum StepSniffer {
  Nothing = -1,
  Mapping,
  Simplifying,
  Drawing,
  Cleaning
}

globalvar StepSniffer stepSniffer = StepSniffer.Nothing;
globalvar Vector[] order = [
  Vector( 0,  0,  1), 
  Vector(-1,  0,  1), 
  Vector(-1,  0,  0), 
  Vector(-1,  0, -1), 
  Vector( 0,  0, -1), 
  Vector( 1,  0, -1), 
  Vector( 1,  0,  0),
  Vector( 1,  0,  1)
];
globalvar Player[] mainDummies = [];

playervar Player[] helperDummies = [];
playervar Vector[] dummyOrder = order;
playervar Vector[] cache = [];
playervar Any arrow = null;

rule: '[Sniffer] Step 0: Initialize'
if(step == Step.WorkingSniffer)
if(stepSniffer == StepSniffer.Nothing)
{
  if(dummies.Length < order.Length + 1) {
    SmallMessage(AllPlayers(), 'Not enough dummies available: {dummies.Length}');
    LogToInspector('Not enough dummies available: {dummies.Length}');
    step = Step.Nothing;
    stepSniffer = StepSniffer.Nothing;
  }

  SmallMessage(AllPlayers(), "[Sniffer] Starting");

  mainDummies = dummies.Length >= (order.Length + 1) * 2 ? [dummies[0], dummies[order.Length + 1]] : [dummies[0]];
  // mainDummies = [dummies[0]];

  center = CurrentObjectivePosition() + (Offsets.Get(CurrentMap())[ObjectiveIndex()] || Vector.Zero);

  center = Vector(
    RoundToInteger(center.X * 100) / 100, 
    RoundToInteger(center.Y * 100) / 100, 
    RoundToInteger(center.Z * 100) / 100
  );

  for(Number x = 0; x < mainDummies.Length; x++) {
    for(Number i = 0; i < order.Length + 1; i++) {
      Player dummy: dummies[x * (order.Length + 1) + i];

      dummy.cache = [];
      dummy.helperDummies = [];

      if(i == 0) {
        dummy.Teleport(center);
        dummy.dummyOrder = !x ? order : ShiftAndPush(Reverse(order), -1);

        dummy.arrow = CreateInWorldText(AllPlayers(), "â†“", EvaluateOnce(dummy).EyePosition() + Up() * scale * 10, 3, Clipping.DoNotClip, InworldTextRev.VisibleToAndPosition, Color.Team1);
      } else {
        Player mainDummy: dummies[x * (order.Length + 1)];
        AttachPlayers(dummy, mainDummy, mainDummy.dummyOrder[i - 1] * scale);
        mainDummy.helperDummies += dummy;
      }

      SetFacing(dummy, dummy.dummyOrder[0], Relative.ToWorld);
    }

    Wait();
  }

  stepSniffer = StepSniffer.Mapping;
}

rule: '[Sniffer] Step 1: Mapping'
if(step == Step.WorkingSniffer)
if(stepSniffer == StepSniffer.Mapping)
{
  DisableInspectorRecording();

  while(stepSniffer == StepSniffer.Mapping) {
    for(Number a = 0; a < mainDummies.Length; a++) {
      Player mainDummy: mainDummies[a];

      if(mainDummy.finished)
        continue;

      if(mainDummy.points.Length > 1 && 
        mainDummies.IsTrueForAny((p) => 
          mainDummy.position.DistanceTo(p.points.First()) < 1.5 || 
          mainDummy.position.DistanceTo(p.position) < 1.5 &&
          p != mainDummy
        )
      ) {
        mainDummy.finished = true;
        continue;
      }

      Boolean[] obj = mainDummy.helperDummies.Map((p) => p.IsOnObjective());

      for(Number i = 0; i < mainDummy.helperDummies.Length; i++) {
        if((i == 0 ? !obj.Last && obj[0] : !obj[i - 1] && obj[i])) {
          if(i == 0) break;
          if(i == mainDummy.helperDummies.Length / 2) continue;

          // skip appending point if the bot that's going in the other direction might go further (King's Row)
          if(mainDummy.points.Length == 0 && obj.First) {}
          else {
            mainDummy.points.Append(mainDummy.position);
          }

          mainDummy.dummyOrder = ShiftAndPush(mainDummy.dummyOrder, i);
          mainDummy.helperDummies = ShiftAndPush(mainDummy.helperDummies, i);

          break;
        }
      }
      
      if(!mainDummy.finished) {
        mainDummy.position += mainDummy.dummyOrder[0];
        mainDummy.Teleport(center + mainDummy.position * scale);
      }
    }

    if(mainDummies.IsTrueForAll((e) => e.finished)) {
      stepSniffer = StepSniffer.Simplifying;
    }

    Wait(ServerLoadAverage() > 100 ? 0.032 : 0.016);
  }

  EnableInspectorRecording();
}

rule: '[Sniffer] Step 2: Simplifying'
if(step == Step.WorkingSniffer)
if(stepSniffer == StepSniffer.Simplifying)
{
  SmallMessage(AllPlayers(), "[Sniffer] Simplifying");

  DisableInspectorRecording();

  foreach(Player mainDummy in mainDummies) {
    if(mainDummy != mainDummies[0]) {
      mainDummy.points.Reverse();
    }

    outline.ConcatBigArray(mainDummy.points);

    mainDummy.Teleport(SpawnPoints(TeamOf(mainDummy))[0]);
    DestroyInWorldText(mainDummy.arrow);
    mainDummy.arrow = null;

    Wait();
  }

  EnableInspectorRecording();
  LogToInspector($"Smoothing using Vector direction {outline.Length} points");
  DisableInspectorRecording();

  for(Number i = 0; i < 8; i++) {
    count = outline.Length;
    outline = SmoothenBetweenVectors(outline);

    EnableInspectorRecording();
    LogToInspector($"Pass {i} finished, length: {outline.Length}");
    DisableInspectorRecording();
    
    if(count - outline.Length <= 1)
      break;
  }

  EnableInspectorRecording();
  LogToInspector($"Smoothing using RDP {outline.Length} points");
  DisableInspectorRecording();

  outline = SmoothenRDP(outline, 1, true);

  Wait();

  EnableInspectorRecording();

  stepSniffer = StepSniffer.Drawing;
}

rule: '[Sniffer] Step 3: Drawing'
if(step == Step.WorkingSniffer)
if(stepSniffer == StepSniffer.Drawing)
{
  SmallMessage(AllPlayers(), "[Sniffer] Drawing");
  LogToInspector($"Drawing {outline.Length} points");

  DisableInspectorRecording();

  for(Number i = 0; i < outline.Length; i++) {
    // TODO: make a setting to snap effects to player's Y position
    // TODO: start generating at player's Y position
    // TODO: move generating outline to `main.del`
    Vector pos: Vector(center.X, HostPlayer().Position().Y + 0.25, center.Z);

    effects += CreateEffect(AllPlayers(), Effect.Sphere, Color.Red, pos + EvaluateOnce(outline.Get(i)) * scale, scale * 2, EffectRev.PositionAndRadius);

    effects += CreateBeamEffect(AllPlayers(), BeamType.GrappleBeam, pos + EvaluateOnce(outline.Get(i == 0 ? outline.Length - 1 : i - 1)) * scale, pos + EvaluateOnce(outline.Get(i)) * scale, Color.Red, EffectRev.PositionAndRadius);

    Wait();
  }

  EnableInspectorRecording();

  stepSniffer = StepSniffer.Cleaning;
}

rule: '[Sniffer] Step 4: Cleaning'
if(step == Step.WorkingSniffer)
if(stepSniffer == StepSniffer.Cleaning)
{
  SmallMessage(AllPlayers(), "[Sniffer] Finished");

  foreach(Player mainDummy in mainDummies) {
    DetachPlayers(mainDummy.helperDummies);
  }

  step = Step.Nothing;
  stepSniffer = StepSniffer.Nothing;
}
