import './actions/index.del';

globalvar Number timelineActionsId = -1;

struct Timeline {
  public Action[] actions;
  public Number index;
  public Boolean isPlaying;
  public Boolean isRepeating;

  public static Timeline New():
    { actions: [], index: 0, isPlaying: false, isRepeating: false };

  // TODO: info about not editing while playing
  public void AddAction(ref Timeline timelineRef, in Action action) {
    timelineActionsId++;
    timelineRef.actions += [{id: timelineActionsId, ..action}];
  }

  public void AddAction(ref Timeline timelineRef, in Action action, in Number index) {
    timelineActionsId++;
    timelineRef.actions = 
      timelineRef.actions.Slice(0, index) + 
      [{id: timelineActionsId, ..action}] +
      timelineRef.actions.Slice(index, 999);
  }

  public void Play(ref Timeline timelineRef) {
    timelineRef.isPlaying = true;
  }

  public void Pause(ref Timeline timelineRef) {
    timelineRef.isPlaying = false;
  }

  public void Stop(ref Timeline timelineRef) {
    timelineRef.isPlaying = false;
    timelineRef.index = 0;
  }

  public void SetRepeat(ref Timeline timelineRef, in Boolean repeat) {
    timelineRef.isRepeating = repeat;
  }

  // to be used in a rule
  public void RuleLogic(ref Timeline timelineRef) {
    for(timelineRef.index; timelineRef.index < timelineRef.actions.Length; timelineRef.index++) {
      Action action: timelineRef.actions[timelineRef.index];
      if(action.disabled) continue;
      action.code();
      if(!timelineRef.isPlaying) break;
    }

    if(timelineRef.index == timelineRef.actions.Length)
      timelineRef.index = 0;

    if(timelineRef.isRepeating)
      LoopIfConditionIsTrue();

    timelineRef.isPlaying = false;
  }
}
