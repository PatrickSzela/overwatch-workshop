import '../utils/string.formatters.del';

class PickPosition {
  public static Number MAX_DISTANCE: 100;
  public static Number RADIUS: 0.25;
  public static Number TEXT_SIZE: 1;
  public static Button CHANGE_DISTANCE_BUTTON_INCREASE: Button.PrimaryFire;
  public static Button CHANGE_DISTANCE_BUTTON_DECREASE: Button.SecondaryFire;
  public static String CHANGE_DISTANCE_DESCRIPTION: $"Use {ButtonFormatterSingle(CHANGE_DISTANCE_BUTTON_INCREASE)}​ or {ButtonFormatterSingle(CHANGE_DISTANCE_BUTTON_DECREASE)}​ to increase or decrease Ray Cast distance";

  public static Vector RayCast(in Player player, in Number distance = MAX_DISTANCE): RayCastHitPosition(player.EyePosition(), player.EyePosition() + player.FacingDirection() * distance, [], [], false);
  public Vector position: PickPosition.RayCast(EventPlayer(), rayCastDistance);
  public Number distance: EventPlayer().EyePosition().DistanceTo(position);
  public Number rayCastDistance;
  public Boolean active;

  private Any[] effects = [];
  private Any[] texts = [];
  private Any[] additionalEffects = [];
  private Any[] additionalTexts = [];

  public constructor() {
    rayCastDistance = MAX_DISTANCE;
    active = false;
  }

  public void Enable(Color color!) "[PickPosition] Enable" {
    active = true;

    Render(
      effectStorage: effects,
      textStorage: texts,
      color: color,
      position: position,
      text: $"Position: {position}\nRay Cast Distance: {rayCastDistance + 0.0001}m"
    );
  }

  public void Disable() "[PickPosition] Disable" {
    active = false;

    foreach(Any effect! in effects)
      DestroyEffect(effect);
    foreach(Any effect! in texts)
      DestroyInWorldText(effect);

    effects = [];
    texts = [];
  }

  // since it's a while loop, can't use Crouch because it breaks closing menu...
  public void ChangeDistance(Button button!) "[PickPosition] Change Distance" {
    while((EventPlayer().IsButtonHeld(CHANGE_DISTANCE_BUTTON_INCREASE) || EventPlayer().IsButtonHeld(CHANGE_DISTANCE_BUTTON_DECREASE)) && active) {
      rayCastDistance += button == CHANGE_DISTANCE_BUTTON_INCREASE ? 0.1 : -0.1;
      rayCastDistance = Max(1, rayCastDistance);
      MinWait();
    }
  }

  // this CANNOT be a subroutine
  public void CreateAdditionalSphere(in Vector position!, in Color color!, in String text! = null, in Vector lineEnd! = null) {
    Render(
      effectStorage: additionalEffects,
      textStorage: additionalTexts,
      color: color,
      position: position,
      text: text,
      lineEnd: lineEnd
    );
  }

  public void DestroyAdditionalSpheres() "[PickPosition] Disable" {
    foreach(Any effect! in additionalEffects)
      DestroyEffect(effect);
    foreach(Any effect! in additionalTexts)
      DestroyInWorldText(effect);

    additionalEffects = [];
    additionalTexts = [];
  }

  // this CANNOT be a subroutine
  public void Render(ref Any[] effectStorage!, ref Any[] textStorage!, in Vector position!, in Color color!, in String text! = null, in Vector lineEnd! = null) {
    effectStorage += CreateEffect(
      EventPlayer(),
      Effect.Sphere,
      color,
      UpdateEveryFrame(position),
      RADIUS,
      EffectRev.PositionRadiusAndColor
    );

    if(lineEnd != null) {
      effectStorage += CreateBeamEffect(
        EventPlayer(),
        BeamType.GrappleBeam,
        lineEnd,
        UpdateEveryFrame(position),
        Color.Black,
        EffectRev.PositionAndRadius
      );
    }

    if(text != null) {
      textStorage += CreateInWorldText(
        EventPlayer(),
        $"{text}\n",
        UpdateEveryFrame(position),
        TEXT_SIZE,
        Clipping.DoNotClip,
        InworldTextRev.VisibleToPositionStringAndColor
      );
    }
  }
}
