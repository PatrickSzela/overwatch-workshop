import '../utils/dictionary.del';
import '../utils/string.formatters.del';
import '../utils/button.allButtons.del';
import './menu.del';
import './components/component.del';

# List of currently pressed buttons by a player.
playervar Button[] buttonsHeld = [];

// TODO: remove?
struct Previous<T> {
  public T current;
  public T previous;
}

single struct RenderedText {
  public Color color;
  public String text;
}

single struct HistoryItem {
  public String id;
  public Number outerScroll;
  public Number innerScroll;

  public static HistoryItem BASE: { id: '', innerScroll: 0, outerScroll: 0 };
}

struct RenderedTexts {
  public RenderedText[] title;
  public RenderedText[] separators;
  public RenderedText[] items;
  public RenderedText[] description;

  public RenderedText[] merged;

  public static RenderedTexts BASE: {
    title: [], separators: [], items: [], description: [], merged: []
  };
}

single struct ComponentParent {
  public Number parentIdx;
  public Component component;
}

# Holds current state of `Menu` for a player and handles logic for displaying and controlling every `Component` and its derivatives.
class MenuState {
  # Button used to go back to the previous page (or close menu when in root).
  public static Button BUTTON_GO_BACK: Button.Ultimate;
  # Maximum number of visible items.
  public static Number MAX_ITEMS: Menu.MAX_ITEMS;

  # Whether player has access to menu.
  public Boolean isEnabled;
  # Whether menu is currently open.
  public Boolean isOpen;
  # Whether player can navigate the menu. Items will still receive navigation events.
  public Boolean isLocked;
  # Combination of buttons used to toggle menu on and off.
  public Button[] _toggleMenu;
  # List of available items on current page.
  public Component[] items;
  # Index of currently hovered item in `items`.
  public Number hoveredItemIdx;
  # Currently hovered item.
  public Component hoveredItem: items[hoveredItemIdx];
  # Stack of IDs of visited pages.
  public HistoryItem[] history;
  # ID of currently open page.
  public String pageId: history.Last.id;
  # ID of root page.
  public String _rootPageId;
  # List of items that should be re-rendered.
  public Number[] rerenderItems;
  # List of rendered items.
  public RenderedTexts renderedTexts;
  # List of additional descriptions that will be show on current page.
  public Description[] descriptions;
  # List of currently visible items.
  public Component[] visibleItems: items.Slice(history.Last.outerScroll, MAX_ITEMS);

  # Stores relation of named component to item in `items`. 
  public Dictionary<String, ComponentParent[]> namedComponentToItem = { Keys: [], Values: [] };

  Number firstItemIdx: items.IndexOf(items.FilteredArray((i, idx) => !i.disabled).First);
  Number lastItemIdx: items.IndexOf(items.FilteredArray((i, idx) => !i.disabled).Last);

  # Currently assigned global menu.
  protected Menu _menu;
  # Player to which this `MenuState` is assigned to.
  protected Player _player;

  public constructor(ref Menu menu, in String rootPageId, in Button[] toggleMenu, in Boolean enabled = true) {
    _menu = menu;
    _player = EventPlayer();
    _toggleMenu = toggleMenu;
    _rootPageId = rootPageId;

    history = [{ id: rootPageId, ..HistoryItem.BASE }];
    items = [];
    isLocked = false;
    isEnabled = enabled;

    rerenderItems = [];

    Render();
  }

  // helpers
  public void SetTitle(in String title) {
    RenderTitle(title);
  }
  
  public void SetEnabled(Boolean enabled!) "[MenuState] Set Enabled" {
    if(enabled != isEnabled) {
      if(isOpen) Close();
      isEnabled = enabled;
    }
  } 

  // TODO: instead of adding every item in a loop, gather them all in an array manually and set dictionary
  private void RegisterNamedItem(Component item!, Number parentIdx!) "[MenuState] Handle Named Item" {
    if(item.name) {
      ComponentParent[] old! = namedComponentToItem.Contains(item.name) ? namedComponentToItem.Get(item.name) : [];
      old += [<ComponentParent>{ component: item, parentIdx: parentIdx }];

      Dictionary<String, ComponentParent[]>.SetOrAdd(namedComponentToItem, item.name, old);
    }
  }

  public void AddItems(in Component[] items) {
    this.items += items;
    rerenderItems = items.Map((_, idx) => idx);

    for(Number i! = 0; i < items.Length; i++) {
      Component item: items[i];
      RegisterNamedItem(item, i);
      if(item.child) {
        RegisterNamedItem(item.child, i);
      }
    }

    HandleScroll();
  }

  // phase 1: handle events
  public void Open() "[MenuState] Open" {
    if(!isOpen && isEnabled) {
      isOpen = true;

      hoveredItem.OnEnter();
      Render();

      _player.SetMoveSpeed(0);

      foreach (Button button! in allButtons)
        DisallowButton(_player, button);
    }
  }

  public void Close() "[MenuState] Close" {
    if(isOpen) {
      isOpen = false;
      
      hoveredItem.OnLeave();
      Render();

      // TODO: store & restore previous speed in case it was modified - how?
      _player.SetMoveSpeed(100);

      foreach (Button button! in allButtons)
        AllowButton(_player, button);
    }
  }

  public void CreatePage(String title!, Component[] items!, Description[] descriptions! = []) "[MenuState]: Create Page" {
    SetTitle(title);
    AddItems(items);

    foreach(Description desc! in descriptions)
      AddDescription(desc);

    if(history.Length == 1 && !isLocked) {
      Description desc1: {text: "Use [↑] or [↓] to navigate menu", order: -1, ..Description.BASE};
      Description desc2: {text: $"Press {ButtonFormatterSingle(BUTTON_GO_BACK)}​ to go back", order: -1, ..Description.BASE};
      AddDescription(desc1);
      AddDescription(desc2);
    }

    if(isOpen) {
      hoveredItem.OnEnter();
      Render();
    }
  }

  public void DestroyPage() "[MenuState]: Destroy Page" {
    if(isOpen) {
      hoveredItem.OnLeave();
    }

    buttonsHeld = [];
    descriptions = [];
    namedComponentToItem = { Keys: [], Values: [] };

    foreach(Component component! in items) {
      if(component.child) {
        delete(component.child);
      }

      delete(component);
    }

    items = [];
  }
  
  public virtual void Navigate(Vector direction!) "[MenuState]: Navigate" {
    hoveredItem.OnNavigate(direction);
    rerenderItems += hoveredItemIdx;

    if(!isLocked && (direction == Down() || direction == Up())) {
      Number offset! = 0;
      Number hov! = hoveredItemIdx;

      if(direction == Down()) {
        Number nextItemIdx! = items.IndexOf(items.FilteredArray((i, idx) => !i.disabled && idx > hov).First);

        offset = (nextItemIdx == -1 ? firstItemIdx : nextItemIdx) - hov;
      } else if(direction == Up()) {
        Number prevItemIdx! = items.IndexOf(items.FilteredArray((i, idx) => !i.disabled && idx < hov).Last);

        offset = (prevItemIdx == -1 ? lastItemIdx : prevItemIdx) - hov;
      }

      if(offset != 0) {
        hoveredItem.OnLeave();
        history[history.Length - 1].innerScroll += offset;
        HandleScroll(); 
        hoveredItem.OnEnter();
        rerenderItems += hoveredItemIdx;
      }
    }

    Render();
  }

  public virtual void ButtonDown(in Button button) {
    buttonsHeld += button;

    if(!isOpen) {
      if(buttonsHeld == _toggleMenu) {
        Open();
      }
    } else {
      hoveredItem.OnButtonDown(button);

      if(!isLocked) {
        if(buttonsHeld == _toggleMenu) {
          Close();
        } else if(buttonsHeld == [BUTTON_GO_BACK]) {
          GoBack();
        }
      }
    }

    if(isOpen) {
      rerenderItems += hoveredItemIdx;
      Render();
    }
  }

  public virtual void ButtonUp(Button button!) "[MenuState]: Button Up" {
    // when changing page `buttonsHeld` is being cleared
    if(!buttonsHeld.Contains(button)) return;

    ModifyVariable(buttonsHeld, Operation.RemoveFromArrayByValue, button);

    if(isOpen) {
      hoveredItem.OnButtonUp(button);
      rerenderItems += hoveredItemIdx;
      Render();
    }
  }

  // phase 3: render
  public void RenderClosedItems() {
    renderedTexts.merged = [
      { 
        text: $"Press {ButtonFormatter(_toggleMenu)}​ to toggle Menu", 
        color: Color.White
      }
    ];
  }

  public void RenderTitle(in String title) {
    renderedTexts.title = [
      { 
        text: title,
        color: Color.White
      }
    ];
  }

  public void RenderSeparators() "[MenuState] Render Separators" {
    renderedTexts.separators = [
      { 
        text: $"──────────────────────{items.Length < MAX_ITEMS ? '─' : history.Last.outerScroll == 0 ? '△' : '▲'}──────────────────────", 
        color: Color.White 
      },
      {
        text: $"──────────────────────{items.Length < MAX_ITEMS ? '─' : history.Last.outerScroll == items.Length - MAX_ITEMS ? '▽' : '▼'}──────────────────────",
        color: Color.White
      }
    ];
  }

  public void RenderDescription() {
    Description[] descriptionArr! = hoveredItem.description;
    if(hoveredItem.child) {
      foreach(Description arr! in hoveredItem.child.description)
        descriptionArr += arr;
    }

    foreach(Description arr! in descriptions)
      descriptionArr += arr;

    Any[][] descr! = descriptionArr.Map((i) => <Any[]>[i.text, i.color, i.visible, i.order]).FilteredArray((i) => i[2]).SortedArray((i) => i[3]);

    renderedTexts.description = descr.Map((i) => <RenderedText>{text: i[0], color: i[1]});
  }

  public void PrepareVisibleItems() {
    // LogToInspector($"Rerendering: {rerenderItems.Length}");

    foreach(Number itemIdx! in rerenderItems) {
      Component item! = items[itemIdx];
      // called here, not in Component because it won't work
      if(item.child) {
        item.child.FormatText();
      }

      item.FormatText();
    }

    if(rerenderItems.Contains(hoveredItemIdx))
      RenderDescription();
    
    rerenderItems = [];
  }

  public void RenderVisibleItems() {
    // TODO: edit only rerendered items
    renderedTexts.items = visibleItems.Map((i, idx) => <RenderedText>{ 
      text: $"{!i.disabled ? hoveredItemIdx == idx + history.Last.outerScroll ? '● ' : '○ ' : ''}{i.renderedText}",
      color: i.color 
    });
  }

  public void MergeTexts() {
    renderedTexts.merged = renderedTexts.title + [renderedTexts.separators[0]] + renderedTexts.items;

    if(items.Length > MAX_ITEMS || renderedTexts.description.Length)
      renderedTexts.merged += [renderedTexts.separators[1]];

    renderedTexts.merged += renderedTexts.description;
  }

  public void Render() "[MenuState] Render" {
    if(isOpen) {
      PrepareVisibleItems();
      RenderVisibleItems();
      MergeTexts();
    } else {
      RenderClosedItems();
    }
  }

  private void HandleScroll() "[MenuState]: Handle Scroll" {
    Number idx! = history.Length - 1;
    Number offset! = 0;

    if(history.Last.innerScroll > MAX_ITEMS - 1) {
      offset = history.Last.innerScroll - (MAX_ITEMS - 1);
      history[idx] = {innerScroll: MAX_ITEMS - 1, outerScroll: history.Last.outerScroll + offset, ..history[idx]};
    } else if(history.Last.innerScroll < 0) {
      offset = history.Last.innerScroll;
      history[idx] = {innerScroll: 0, outerScroll: history.Last.outerScroll + offset, ..history[idx]};
    }

    if(hoveredItem.disabled) {
      history[idx].innerScroll = firstItemIdx;
    }

    CalculateCurrentIdx();
    RenderSeparators();
  }

  private void CalculateCurrentIdx() {
    hoveredItemIdx = history.Last.innerScroll + history.Last.outerScroll;
  }

  public virtual void GoTo(Any id!) "[MenuState]: Go To" {
    DestroyPage();
    history += { id: id, ..HistoryItem.BASE };
  }

  public virtual void GoBack() "[MenuState]: Go Back" {    
    if(history.Length == 1) {
      Close();
      return;
    }

    DestroyPage();
    history.ModRemoveByIndex(history.Length - 1);

    CalculateCurrentIdx();
  }

  public void AddDescription(in Description desc) {
    this.descriptions += desc;
  }

  public void WaitUntilButtonDown(in String id, in Button button) {
    WaitUntil(onButtonDown(id, button), 99999);
  }

  public void WaitUntilButtonUp(in String id, in Button button) {
    WaitUntil(!onButtonDown(id, button), 99999);
  }

  // events
  public Boolean onButtonDown(in String id, in Button button): isOpen && hoveredItem.id == id && buttonsHeld.Contains(button);
   
  public Boolean onEnter(in String id): isOpen && hoveredItem.id == id;

  public Boolean onNavigate(in String pageId, in Vector direction) {
    Vector diff = ThrottleOf(EventPlayer()) - direction * 0.5;
    Boolean x = AbsoluteValue(diff.X) > 0.5;
    Boolean y = AbsoluteValue(diff.Y) > 0.5;
    return isOpen && hoveredItem.id == pageId && (x && !y || !x && y);
  }
}