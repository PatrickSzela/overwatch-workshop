import './customButtons.del';
import '../utils/index.del';
import '../utils/string.formatters.del';
import '../utils/button.allButtons.del';
import './menu.del';
import './_rules.del';
import './components/component.del';
import './components/text.del';
import './components/link.del';

// TODO: handle case when switching side after players array changes and focusedIndex is wrong

playervar MenuState menuState;
playervar MenuWindow[] menuWindows = [];

single struct RenderedText {
  public Color color;
  public String text;

  public static RenderedText New(in String text, in Color color = COLOR_NEUTRAL): 
    { text: text, color: color };
}

single struct HistoryItem {
  public String id;
  public Number outerScroll;
  public Number innerScroll;

  public static HistoryItem New(in String id): 
    { id: id, innerScroll: 0, outerScroll: 0 };
}

struct RenderedTexts {
  public RenderedText[] titles;
  public RenderedText[] separators;
  public RenderedText[] items;
  public RenderedText[] descriptions;

  public RenderedText[] merged;

  public static RenderedTexts New(): {
    titles: [], separators: [], items: [], descriptions: [], merged: []
  };
}


struct MenuWindow {
  # Maximum number of visible items.
  public static Number MAX_ITEMS: Menu.MAX_ITEMS;

  # Whether window is currently focused.
  public Boolean focused;
  # Whether window is currently open.
  public Boolean open;
  # Whether window should rerender.
  public Boolean shouldRerender;
  # Marked menu as updated.
  public Boolean findClosestFocusableComponent;
  public Boolean updateScroll;
  public Boolean finishNavigate;
  # Combination of buttons used to toggle menu on and off.
  public Button[] toggleWindowKeybind;
  # Whether opening and closing this window is done programmatically.
  public Boolean isRemotelyControlled: !toggleWindowKeybind;
  # List of available items in `menuComponents` variable used on the current page.
  public Number[] indexes;
  # Index of currently focused item in `indexes`.
  public Number focusedIndex;
  # List of currently visible items.
  public Number[] visibleIndexes: indexes.Slice(history.Last.outerScroll, MAX_ITEMS);
  # List of components that can be focused.
  public Number[] enabledIndexes: indexes.FilteredArray((i) => !menuComponents[i].disabled);
  # Currently hovered item.
  public Component focusedComponent: menuComponents[indexes[focusedIndex]];
  # History of opened pages.
  public HistoryItem[] history;
  # ID of currently open page.
  public String pageId: history.Last.id;
  # ID of root page.
  protected String rootPageId;
  # Whether menu is currently in refresh stage.
  public Boolean isRefreshing: pageId == '<REFRESH>';
  # List of additional descriptions that will be show on current page.
  public Description[] pageDescriptions;
  # List of additional descriptions that will be shown until manually removed.
  public Description[] windowDescriptions;
  # List of rendered items.
  public RenderedTexts renderedTexts;

  public static MenuWindow New(in String rootPageId, in Button[] toggleWindowKeybind): { 
    focused: false,
    open: false,
    shouldRerender: true,
    findClosestFocusableComponent: false,
    updateScroll: false,
    finishNavigate: false,
    toggleWindowKeybind: toggleWindowKeybind,
    indexes: [],
    focusedIndex: 0,
    history: [HistoryItem.New(rootPageId)],
    rootPageId: rootPageId,
    pageDescriptions: [],
    windowDescriptions: [],
    renderedTexts: RenderedTexts.New(),
  };

  # Marks menu as updated.
  public ref void MarkFindClosestFocusableComponent() {
    findClosestFocusableComponent = true;
  }

  public ref void MarkUpdateScroll() {
    updateScroll = true;
    // UpdateScroll();
  }

  # Marks menu to rerender.
  public ref void MarkToRerender() {
    shouldRerender = true;
  }

  public ref void SetTitle(in String title) {
    RenderTitle(title);
  }

  public ref void SetFocused() {
    Log($'[{EventPlayer()}] SetFocused');

    focused = true;

    // TODO: STRUCT REWORK restore
    // if(menuState != this) {
    //   menuState.isFocused = false;

    //   if(menuState.isOpen) {
    //     menuState.hoveredItem.OnLeave();
    //   }
      
    //   menuState = this;
    //   isFocused = true;

    //   if(isOpen) {
    //     hoveredItem.OnEnter();
    //   }
    // }
  }

  protected void OnComponentEnter(in Number index = indexes[focusedIndex]) {
    menuComponents[index].onEnter();
    menuComponents[menuComponents[index].childIndex].onEnter();
  }

  protected void OnComponentLeave(in Number index = indexes[focusedIndex]) {
    menuComponents[menuComponents[index].childIndex].onLeave();
    menuComponents[index].onLeave();
  }

  protected void OnComponentNavigate(in Vector direction, in Number index = indexes[focusedIndex]) {
    menuComponents[index].onNavigate(direction);
    menuComponents[menuComponents[index].childIndex].onNavigate(direction);
  }

  protected void OnComponentButtonDown(in Button button, in Number index = indexes[focusedIndex]) {
    menuComponents[index].onButtonDown(button);
    menuComponents[menuComponents[index].childIndex].onButtonDown(button);
  }

  protected void OnComponentButtonUp(in Button button, in Number index = indexes[focusedIndex]) {
    menuComponents[menuComponents[index].childIndex].onButtonUp(button);
    menuComponents[index].onButtonUp(button);
  }

  # Forcefully rerenders specified item (or currently hovered one if no `index` is specified). Call after manually adding description.
  public ref void RerenderItem(in Number index! = -1) {
    Log($'[{EventPlayer()}] RerenderItem');

    menuComponents[index == -1 ? indexes[focusedIndex] : index].MarkToRerender();
    MarkToRerender();
  }

  # Forcefully rerenders all items.
  public ref void RerenderAllItems() {
    Log($'[{EventPlayer()}] RerenderAllItems');

    for(Number i = 0; i < menuComponents.Length; i++)
      menuComponents[i].MarkToRerender();
    
    MarkToRerender();
  }

  public ref void Open() {
    Log($'[{EventPlayer()}] Open');

    if(!open) {
      open = true;

      if(focused) OnComponentEnter();
      MarkToRerender();
    }
  }

  public ref void Close() {
    Log($'[{EventPlayer()}] Close');

    if(open) {
      open = false;
      
      if(focused) OnComponentLeave();
      MarkToRerender();
    }
  }

  // fore some reason `newPageId` must be stored, otherwise its value will be lost when passed on to HistoryItem.New
  public ref void GoToPage(String newPageId!, in Boolean historyReplace = false) {
    Log($'[{EventPlayer()}] GoToPage: going from {pageId} to {newPageId}');

    if(pageId != newPageId) {
      DestroyPage();
      history[history.Length - (historyReplace ? 1 : 0)] = HistoryItem.New(newPageId);
    }
  }

  public ref void GoBack() {
    Log($'[{EventPlayer()}] GoBack');

    if(history.Length == 1) {
      if(!isRemotelyControlled) Close();
      return;
    }

    DestroyPage();
    history.ModRemoveByIndex(history.Length - 1);
  }

  # Add items to the menu.
  public ref void AddItems(in Number[] componentIndexes, in Boolean updateScroll = true) {
    Log($'[{EventPlayer()}] AddItems: Adding {componentIndexes.Length} items');
    indexes += componentIndexes;

    if(updateScroll) {
      MarkFindClosestFocusableComponent();
    }
  }

  # Removes specified items from the menu. Will automatically clean up components in `menuComponents`.
  public ref void RemoveItems(in Number[] componentIndexes, in Boolean updateScroll = true) {
    Log($'[{EventPlayer()}] RemoveItems: Removing {componentIndexes.Length} items');
    indexes -= componentIndexes;
    
    RemoveComponents(componentIndexes);

    if(updateScroll) {
      MarkFindClosestFocusableComponent();
    }
  }

  # Removes all items from the menu. Will automatically clean up components in `menuComponents`.
  public ref void RemoveAllItems(in Boolean callOnItemsChanged = true) {
    RemoveItems(indexes, callOnItemsChanged);
  }

  # Replaces all items in the menu. Will automatically clean up removed components in `menuComponents`.
  public ref void ReplaceItems(in Number[] componentIndexes) {
    Log($'[{EventPlayer()}] ReplaceItems');

    RemoveAllItems(false);
    AddItems(componentIndexes, false);

    // TODO: STRUCT REWORK restore if perf is bad
    // RemoveItems(this.indexes - items, false);
    // AddItems(items - this.indexes, false);

    // // keep the order of passed items
    // this.indexes = items;

    MarkFindClosestFocusableComponent();
  }

  public ref void CreatePage(in String title, in Number[] indexes, in Description[] descriptions = []) {
    Log($'[{EventPlayer()}] CreatePage');

    SetTitle(title);
    AddItems(indexes);

    pageDescriptions += descriptions;
    // foreach(Description desc! in descriptions)
    //   pageDescriptions += desc;

    if(open) {
      OnComponentEnter();

      // `AddItems` already adds items to render queue
      MarkToRerender();
    }
  }

  public ref void DestroyPage() {
    Log($'[{EventPlayer()}] DestroyPage');

    if(open) {
      OnComponentLeave();
    }

    RemoveAllItems(false);

    buttonsHeld = [];
    pageDescriptions = [];
  }
  

  // phase 1: handle events
  public ref void Navigate(in Vector direction, in Boolean navigationLocked) {
    Log($'[{EventPlayer()}] Navigate');

    OnComponentNavigate(direction, focusedIndex);

    if(!navigationLocked && (direction == Down() || direction == Up())) {
      // TODO: STRUCT REWORK move to a func
      Number offset! = 0;
      Number[] it! = enabledIndexes;

      // Log($"current idx: {focusedIndex}");

      if(direction == Down()) {
        Number[] nextItemIdxs! = indexes.FilteredArray((i, idx) => !menuComponents[i].disabled && idx > focusedIndex);

        offset = indexes.IndexOf(nextItemIdxs ? nextItemIdxs.First : it.First) - focusedIndex;

        // Log($"next offset: {offset}");
      } else if(direction == Up()) {
        Number[] prevItemIdxs! = indexes.FilteredArray((i, idx) => !menuComponents[i].disabled && idx < focusedIndex);

        offset = indexes.IndexOf(prevItemIdxs ? prevItemIdxs.Last : it.Last) - focusedIndex;

        // Log($"prev offset: {offset}");
      }

      if(offset != 0) {
        OnComponentLeave();
        
        history[history.Length - 1].innerScroll += offset;
        finishNavigate = true;
        MarkUpdateScroll(); 
      }
    }

    MarkToRerender();
  }

  public ref void ButtonDown(in Button button, in Boolean navigationLocked) {
    Log($'[{EventPlayer()}] ButtonDown');

    if(open) {
      OnComponentButtonDown(button, indexes[focusedIndex]);

      switch(focusedComponent.type) {
        case ComponentType.Link:
          if(buttonsHeld == [focusedComponent.button])
            GoToPage(focusedComponent.value);
          break;
      }

      if(!navigationLocked && buttonsHeld == [BUTTON_BACK]) {
        GoBack();
      }

      MarkToRerender();
    }
  }

  public ref void ButtonUp(in Button button, in Boolean navigationLocked) {
    Log($'[{EventPlayer()}] ButtonUp');

    if(open) {
      OnComponentButtonUp(button, indexes[focusedIndex]);
      MarkToRerender();
    }
  }

  // phase 2: rendering
  protected ref void RenderClosedItems(in Boolean hideKeybindTextWhenClosed) {
    renderedTexts.merged = 
      isRemotelyControlled || hideKeybindTextWhenClosed ? 
        [] : 
        [
          RenderedText.New(
            text: $"Press {ButtonFormatter_Underscores(toggleWindowKeybind)}​ to toggle Menu", 
            color: COLOR_NEUTRAL
          )
        ];
  }

  protected ref void RenderTitle(in String title) {
    renderedTexts.titles = [
      RenderedText.New(title, COLOR_NEUTRAL)
    ];
  }

  protected ref void RenderSeparators() {
    renderedTexts.separators = [
      RenderedText.New(
        text: $"──────────────────────{indexes.Length < MAX_ITEMS ? '─' : history.Last.outerScroll == 0 ? '△' : '▲'}──────────────────────", 
        color: COLOR_NEUTRAL 
      ),
      RenderedText.New(
        text: $"──────────────────────{indexes.Length < MAX_ITEMS ? '─' : history.Last.outerScroll == indexes.Length - MAX_ITEMS ? '▽' : '▼'}──────────────────────",
        color: COLOR_NEUTRAL
      )
    ];
  }

  protected ref void RenderDescriptions() {
    // Description[] descriptions! = focusedComponent.descriptions;

    // if(focusedComponent.hasChild) {
    //   descriptions += menuComponents[focusedComponent.childIndex].descriptions;
    // }

    // descriptions += pageDescriptions + menuDescriptions;

    // renderedTexts.descriptions = descriptions
    //   .FilteredArray((i) => i.visible)
    //   .SortedArray((i) => i.order)
    //   .Map((i) => <RenderedText>{text: i[0], color: i[1]});

    renderedTexts.descriptions = (
      focusedComponent.descriptions + 
      menuComponents[focusedComponent.childIndex].descriptions +
      pageDescriptions + windowDescriptions
    ).FilteredArray((i) => i.visible)
      .SortedArray((i) => i.order)
      .Map((i) => RenderedText.New(text: i[0], color: i[1]));
  }

  protected static String RenderComponent(in Number index) {
    Component item: menuComponents[index];

    switch(item.type) {
      case ComponentType.Text:
        return Text.Render(menuComponents[index]);
      case ComponentType.Value:
        return '';
      case ComponentType.Link:
        return Link.Render(menuComponents[index]);
      case ComponentType.Toggle:
        return '';
      case ComponentType.Checkbox:
        return '';
      case ComponentType.Radio:
        return '';
      case ComponentType.Carousel:
        return '';
      case ComponentType.TextInput:
        return '';
      case ComponentType.NumberInput:
        return '';
    }
  }

  protected ref void RenderVisibleItems() {
    RenderDescriptions();

    Number[] v! = visibleIndexes;

    // Log(indexes.Length);
    // Log(visibleIndexes.Length);

    renderedTexts.items = [];

    for(Number idx! = 0; idx < v.Length; idx++) {
      Number componentIdx: idx + history.Last.outerScroll;
      Number index: v[idx];
      Component item: menuComponents[index];
      Component child: menuComponents[item.childIndex];
      
      Number[] items! = (item.hasChild ? [item.childIndex] : []) + [index];
      // Log($"index {index} has {items.Length} items:");

      if(item.shouldRerender || child.shouldRerender) {
        foreach(Number idx2! in items) {
          // Log($"item {idx2}: label - {menuComponents[idx2].label}, rendered text - {RenderComponent(idx2)}");
          menuComponents[idx2].renderedText = RenderComponent(idx2);
          menuComponents[idx2].shouldRerender = false;
        }

        // Log($'Rerendered: {item.renderedText}');
      }

      renderedTexts.items[idx] = RenderedText.New( 
        text: $"{!item.disabled ? focused && focusedIndex == componentIdx ? '● ' : '○ ' : ''}{item.renderedText}",
        color: item.color 
      );
    }
  }

  protected ref void MergeTexts() {
    renderedTexts.merged = renderedTexts.titles + [renderedTexts.separators[0]] + renderedTexts.items;

    if(indexes.Length > MAX_ITEMS || renderedTexts.descriptions.Length)
      renderedTexts.merged += [renderedTexts.separators[1]];

    renderedTexts.merged += renderedTexts.descriptions;
  }

  public ref void Render(in Boolean hideKeybindTextWhenClosed) {
    Log($'[{EventPlayer()}] Render');

    shouldRerender = false;

    if(open) {
      RenderVisibleItems();
      MergeTexts();
    } else {
      RenderClosedItems(hideKeybindTextWhenClosed);
    }
  }






  public ref void FindClosestFocusableComponent() {
    Log($'[{EventPlayer()}] FindClosestFocusableComponent');

    findClosestFocusableComponent = false;

    // TODO: STRUCT REWORK restore
    // if(!indexes) {
    //   indexes = [emptyTextIndex];
    // } else if(indexes.Length > 1 && indexes.Contains(emptyTextIndex)) {
    //   indexes -= emptyTextIndex;
    // }
    
    // `focusedIndex` is calculated later in `HandleScroll()`
    Number scroll: history.Last.outerScroll + history.Last.innerScroll;
    Number hover: indexes[scroll];

    if(!hover || menuComponents[hover].disabled) {
      Number[] enabled! = enabledIndexes;
      history[history.Length - 1].innerScroll = Max(enabled.First, Min(enabled.Last, scroll));
    }

    MarkUpdateScroll();
  }

  public ref void UpdateScroll() {
    Log($'[{EventPlayer()}] UpdateScroll');

    updateScroll = false;

    Number idx! = history.Length - 1;
    Number offset! = 0;

    if(history.Last.innerScroll > MAX_ITEMS - 1) {
      offset = history.Last.innerScroll - (MAX_ITEMS - 1);
      history[idx] = {
        innerScroll: MAX_ITEMS - 1, 
        outerScroll: history.Last.outerScroll + offset, ..history[idx]
      };
    } else if(history.Last.innerScroll < 0) {
      offset = history.Last.innerScroll;
      history[idx] = {
        innerScroll: 0, 
        outerScroll: Max(0, history.Last.outerScroll + offset), ..history[idx]
      };
    }

    focusedIndex = history.Last.innerScroll + history.Last.outerScroll;
    Log($"new idx: {focusedIndex}");
    RenderSeparators();

    if(finishNavigate) {
      finishNavigate = false;
      OnComponentEnter();
      MarkToRerender();
    }
  }
}

single struct MenuState {
  # Maximum number of visible items.
  public static Number MAX_ITEMS: Menu.MAX_ITEMS;



  # Whether player has access to menu.
  public Boolean enabled;
  # Whether menu is currently open.
  public Boolean open: menuWindows.IsTrueForAny((i) => i.open);
  # Whether player can navigate the menu. Items will still receive navigation events.
  public Boolean navigationLocked;
  # Index of the currently focused window in `windows`.
  public Number focusedWindowIndex;
  # Whether the text explaining how to toggle menu should be hidden when menu is closed.
  public Boolean hideKeybindTextWhenClosed;

  public String[] pageIds: menuWindows.Map((i) => i.pageId);


 


  public static MenuState New(in String rootPageId, in Boolean enabled = true): { 
    enabled: enabled,
    navigationLocked: false,
    focusedWindowIndex: 0,
    hideKeybindTextWhenClosed: false
  };

  public ref void CreatePage(in String pageId, in String title, in Number[] indexes, in Description[] descriptions = []) {
    menuWindows[focusedWindowIndex].CreatePage(title, indexes, descriptions);
  }

  public void ButtonDown(Button button!) "MenuState.ButtonDown" {
    for(Number i! = 0; i < menuWindows.Length; i++) {
      if(buttonsHeld && buttonsHeld == menuWindows[i].toggleWindowKeybind) {
        if(menuWindows[i].open) {
          menuWindows[i].Close();
        } else {
          menuWindows[i].Open();
          menuState.focusedWindowIndex = i;
          menuWindows[i].SetFocused();
        }
      }
    }

    menuWindows[focusedWindowIndex].ButtonDown(button, navigationLocked);
  }

  public void ButtonUp(Button button!) "MenuState.ButtonUp" {
    // when changing page `buttonsHeld` is being cleared
    if(!buttonsHeld.Contains(button)) return;

    menuWindows[focusedWindowIndex].ButtonUp(button, navigationLocked);
  }

  public ref void Navigate(in Vector direction) {
    menuWindows[focusedWindowIndex].Navigate(direction, navigationLocked);
  }

  public ref void RULE_FindClosestFocusableComponent() {
    WaitForeverUntil(menuWindows.IsTrueForAny((i) => i.findClosestFocusableComponent));

    for(Number i = 0; i < menuWindows.Length; i++)
      menuWindows[i].FindClosestFocusableComponent();

    Loop();
  }

  public ref void RULE_UpdateScroll() {
    WaitForeverUntil(menuWindows.IsTrueForAny((i) => i.updateScroll));

    for(Number i = 0; i < menuWindows.Length; i++)
      menuWindows[i].UpdateScroll();

    Loop();
  }

  public ref void RULE_Render() {
    WaitForeverUntil(menuWindows.IsTrueForAny((i) => i.shouldRerender));

    for(Number i = 0; i < menuWindows.Length; i++)
      menuWindows[i].Render(hideKeybindTextWhenClosed);

    Loop();
  }
}



# Holds current state of `Menu` for a player and handles logic for displaying and controlling every `Component` and its derivatives.
class MenuState3 {
  # Maximum number of visible items.
  public static Number MAX_ITEMS: Menu.MAX_ITEMS;

  # Whether player has access to menu.
  public Boolean isEnabled;
  # Whether menu is currently open.
  public Boolean isOpen;
  # Whether player can navigate the menu. Items will still receive navigation events.
  public Boolean isLocked;
  # Whether opening and closing menu logic is handled from outside.
  public Boolean isPuppet;
  # Whether this menu is currently used menu.
  public Boolean isFocused;
  # Whether menu is currently in refresh stage.
  public Boolean isRefreshing: pageId == '<REFRESH>';
  # Whether the text explaining how to toggle menu should be hidden when menu is closed.
  public Boolean hideTextWhenClosed;
  # Whether menu should rerender.
  public Boolean shouldRerender;
  # Combination of buttons used to toggle menu on and off.
  public Button[] _toggleMenu;
  # ID of root page.
  public String _rootPageId;
  # List of available items on current page.
  public Number[] indexes;
  # Index of currently hovered item in `items`.
  public Number hoveredIndex;
  # List of currently visible items.
  public Number[] visibleIndexes: indexes.Slice(history.Last.outerScroll, MAX_ITEMS);
  # List of components that aren't disabled (can be hovered).
  public Number[] enabledItemsIndexes: indexes.FilteredArray((i) => !menuComponents[i].disabled).Map((i) => i);
  # Currently hovered item.
  public Component hoveredItem: menuComponents[hoveredIndex];
  # Stack of IDs of visited pages.
  public HistoryItem[] history;
  # ID of currently open page.
  public String pageId: history.Last.id;
  # List of rendered items.
  public RenderedTexts renderedTexts;
  # List of additional descriptions that will be show on current page.
  public Description[] descriptionsPage;
  # List of additional descriptions that will be shown until manually removed.
  public Description[] descriptionsMenu;
  # Component that will be displayed when there are no items in menu
  protected Number emptyTextIndex;

  public Number[] childIndexes(in Number[] indexes): indexes.FilteredArray((i) => menuComponents[i].childIndex).Map((i) => menuComponents[i].childIndex);

  public constructor(in String rootPageId, in Button[] toggleMenu, in Boolean enabled = true, in Boolean puppet = false) {
    _toggleMenu = toggleMenu;
    _rootPageId = rootPageId;

    if(rootPageId != null)
      history = [HistoryItem.New(rootPageId)];
    else 
      history = [];
    
    indexes = [];
    isLocked = false;
    isFocused = false;
    isEnabled = enabled;
    isPuppet = puppet;
    hoveredIndex = 0;

    renderedTexts = RenderedTexts.New();
    // TODO: STRUCT REWORK restore
    // emptyTextIndex = menuComponents.Length;
    // indexes += Text.New("It's a bit empty in here...");

    // render closed title
    MarkToRerender();
  }

  // helpers
  public Boolean HistoryContains(in String pageId): 
    history.Map((i) => i.id).Contains(pageId);

  public void SetTitle(in String title) {
    RenderTitle(title);
  }

  # Forcefully rerenders specified item (or currently hovered one if no `index` is specified). Call after manually adding description.
  public void RerenderItem(Number index! = -1) "[MenuState] Rerender Item" {
    Log($'{EventPlayer()}: RerenderItem');

    menuComponents[index == -1 ? hoveredIndex : index].MarkToRerender();
    MarkToRerender();
  }

  # Forcefully rerenders all items.
  public void RerenderAllItems() "[MenuState] Rerender All Items" {
    Log($'{EventPlayer()}: RerenderAllItems');

    for(Number i = 0; i < menuComponents.Length; i++)
      menuComponents[i].MarkToRerender();
    
    MarkToRerender();
  }
  
  public void SetEnabled(Boolean enabled!) "[MenuState] Set Enabled" {
    Log($'{EventPlayer()}: SetEnabled');

    if(enabled != isEnabled) {
      Close();
      isEnabled = enabled;
    }
  }

  // TODO: STRUCT REWORK restore
  public void SetFocused() "[MenuState] Set Focused" {
    Log($'{EventPlayer()}: SetFocused');

    isFocused = true;

    // if(menuState != this) {
    //   menuState.isFocused = false;

    //   if(menuState.isOpen) {
    //     menuState.hoveredItem.OnLeave();
    //   }
      
    //   menuState = this;
    //   isFocused = true;

    //   if(isOpen) {
    //     hoveredItem.OnEnter();
    //   }
    // }
  }

  # NOTE: This won't rerender the menu
  public void SetHoveredItemIndex(Number index!) "[MenuState] Set Hovered Item Index" {
    Log($'{EventPlayer()}: SetHoveredItemIdx');

    history[history.Length - 1] = { innerScroll: index, outerScroll: 0, ..history.Last };

    HandleScroll();
  }

  public void AddItems(Number[] newItemsIndexes!, Boolean callOnItemsChanged! = true) "[MenuState] Add Items" {
    // TODO: for some reason this doesn't work.... convert to struct first?
    indexes += newItemsIndexes;

    Log($'{EventPlayer()}: AddItems - adding {newItemsIndexes.Length} items, {indexes.Length} in total');
    
    if(callOnItemsChanged) {
      OnItemsChanged();
    }
  }

  public void RemoveItems(Number[] indexes!, Boolean callOnItemsChanged! = true) "[MenuState] Remove Items" {
    Log($'{EventPlayer()}: RemoveItems');

    indexes += childIndexes(indexes);
    this.indexes -= indexes;
    
    // TODO: STRUCT REWORK restore
    // foreach(Number index! in indexes) {
    //   if(index == emptyText) continue;      
    // }

    menuComponents -= indexes.Map((i) => menuComponents[i]);
    
    if(callOnItemsChanged) {
      OnItemsChanged();
    }
  }

  public void RemoveAllItems(Boolean callOnItemsChanged! = true) {
    RemoveItems(this.indexes, callOnItemsChanged);
  }

  public void ReplaceItems(Number[] newItemsIndexes!) "[MenuState] Replace Items" {
    Log($'{EventPlayer()}: ReplaceItems');

    RemoveAllItems(false);
    AddItems(newItemsIndexes, false);

    // RemoveItems(this.indexes - items, false);
    // AddItems(items - this.indexes, false);

    // // keep the order of passed items
    // this.indexes = items;

    OnItemsChanged();
  }

  protected void OnItemsChanged() "[MenuState] On Items Changed" {
    Log($'{EventPlayer()}: OnItemsChanged');

    if(!indexes) {
      indexes = [emptyTextIndex];
    } else if(indexes.Length > 1 && indexes.Contains(emptyTextIndex)) {
      indexes -= emptyTextIndex;
    }
    
    // hoveredItemIdx is calculated later in `HandleScroll()`
    Number scroll! = history.Last.outerScroll + history.Last.innerScroll;
    Number hover: indexes[scroll];

    if(!hover || menuComponents[hover].disabled) {
      Number[] enabled! = enabledItemsIndexes;
      history[history.Length - 1].innerScroll = Max(enabled.First, Min(enabled.Last, scroll));
    }

    HandleScroll();
  }

  // phase 1: handle events
  public void Open() "[MenuState] Open" {
    Log($'{EventPlayer()}: Open');

    if(!isOpen && isEnabled) {
      isOpen = true;

      // TODO: STRUCT REWORK restore
      // if(isFocused) hoveredItem.OnEnter();
      MarkToRerender();
    }
  }

  public void Close() "[MenuState] Close" {
    Log($'{EventPlayer()}: Close');

    if(isOpen) {
      isOpen = false;
      
      // TODO: STRUCT REWORK restore
      // if(isFocused) hoveredItem.OnLeave();
      MarkToRerender();
    }
  }

  public void CreatePage(String title!, Number[] items!, Description[] descriptions! = []) "[MenuState] Create Page" {
    Log($'{EventPlayer()}: CreatePage');

    SetTitle(title);
    AddItems(items);

    Log($"Created page: {title} with {indexes.Length} items in total");

    foreach(Description desc! in descriptions)
      descriptionsPage += desc;

    if(isOpen) {
      // TODO: STRUCT REWORK restore
      // hoveredItem.OnEnter();

      // `AddItems` already adds items to render queue
      MarkToRerender();
    }
  }

  public void DestroyPage() "[MenuState] Destroy Page" {
    Log($'{EventPlayer()}: DestroyPage');

    if(isOpen) {
      // TODO: STRUCT REWORK restore
      // hoveredItem.OnLeave();
    }

    RemoveItems(indexes, false);

    buttonsHeld = [];
    descriptionsPage = [];
  }

  public virtual void Navigate(Vector direction!) "[MenuState] Navigate" {
    EnableInspectorRecording();
    Log($'{EventPlayer()}: Navigate');
    DisableInspectorRecording();

    // TODO: STRUCT REWORK restore
    // hoveredItem.OnNavigate(direction);

    if(!isLocked && (direction == Down() || direction == Up())) {
      Number offset! = 0;
      Number hov: hoveredIndex;
      Number[] it! = enabledItemsIndexes;

      if(direction == Down()) {
        Number nextItemIdx! = indexes.FilteredArray((i, idx) => !menuComponents[i].disabled && idx > hov).First;

        offset = (nextItemIdx == -1 ? indexes.IndexOf(it.First) : nextItemIdx) - hov;
      } else if(direction == Up()) {
        Number prevItemIdx! = indexes.FilteredArray((i, idx) => !menuComponents[i].disabled && idx < hov).Last;

        offset = (prevItemIdx == -1 ? indexes.IndexOf(it.Last) : prevItemIdx) - hov;
      }

      if(offset != 0) {
        // TODO: STRUCT REWORK restore
        // hoveredItem.OnLeave();
        
        history[history.Length - 1].innerScroll += offset;
        HandleScroll(); 

        // TODO: STRUCT REWORK restore
        // hoveredItem.OnEnter();
      }
    }

    MarkToRerender();
  }

  public virtual void ButtonDown(Button button!) "[MenuState] Button Down" {
    Log($'{EventPlayer()}: ButtonDown');

    if(!isOpen) {
      if(buttonsHeld == _toggleMenu && !isPuppet) {
        Open();
      }
    } else {
      // TODO: STRUCT REWORK restore
      // hoveredItem.OnButtonDown(button);

      if(!isLocked) {
        if(buttonsHeld == _toggleMenu && !isPuppet) {
          Close();
        } else if(buttonsHeld == [BUTTON_BACK]) {
          GoBack();
        }
      }
    }

    if(isOpen) {
      MarkToRerender();
    }
  }

  public virtual void ButtonUp(Button button!) "[MenuState] Button Up" {
    Log($'{EventPlayer()}: ButtonUp');

    // when changing page `buttonsHeld` is being cleared
    if(!buttonsHeld.Contains(button)) return;

    if(isOpen) {
      // TODO: STRUCT REWORK restore
      // hoveredItem.OnButtonUp(button);
      MarkToRerender();
    }
  }

  // phase 2: render
  protected void RenderClosedItems() {
    renderedTexts.merged = isPuppet || hideTextWhenClosed ? [] : [
      { 
        text: $"Press {ButtonFormatter_Underscores(_toggleMenu)}​ to toggle Menu", 
        color: COLOR_NEUTRAL
      }
    ];
  }

  protected void RenderTitle(in String title) {
    renderedTexts.titles = [
      { 
        text: title,
        color: COLOR_NEUTRAL
      }
    ];
  }

  protected void RenderSeparators() {
    renderedTexts.separators = [
      { 
        text: $"──────────────────────{indexes.Length < MAX_ITEMS ? '─' : history.Last.outerScroll == 0 ? '△' : '▲'}──────────────────────", 
        color: COLOR_NEUTRAL 
      },
      {
        text: $"──────────────────────{indexes.Length < MAX_ITEMS ? '─' : history.Last.outerScroll == indexes.Length - MAX_ITEMS ? '▽' : '▼'}──────────────────────",
        color: COLOR_NEUTRAL
      }
    ];
  }

  protected void RenderDescription() {
    Description[] descriptionArr = hoveredItem.descriptions;

    if(hoveredItem.childIndex) {
      descriptionArr += menuComponents[hoveredItem.childIndex].descriptions;
    }

    descriptionArr += descriptionsPage + descriptionsMenu;

    renderedTexts.descriptions = descriptionArr
      .FilteredArray((i) => i.visible)
      .SortedArray((i) => i.order)
      .Map((i) => <RenderedText>{text: i[0], color: i[1]});
  }

  protected void RenderVisibleItems() {
    RenderDescription();

    Number[] v = visibleIndexes;

    renderedTexts.items = [];

    for(Number idx = 0; idx < v.Length; idx++) {
      Number actualIdx: idx + history.Last.outerScroll;
      Number index: v[idx];
      Component item: menuComponents[index];
      
      if(item.shouldRerender || menuComponents[item.childIndex].shouldRerender) {
        // Log($'Rerendering: {item.text}');

        // `Render()` of a child called here, not in Component because it becomes recursive for some reason
        if(item.childIndex) {
          // TODO: STRUCT REWORK restore
          // item.child.Render();
          // item.child.shouldRerender = false;
        }

        // item.Render();
        // item.shouldRerender = false;
      }

      renderedTexts.items[idx] = { 
        text: $"{!item.disabled ? isFocused && hoveredIndex == actualIdx ? '● ' : '○ ' : ''}{item.renderedText}",
        color: item.color 
      };
    }
  }

  protected void MergeTexts() {
    renderedTexts.merged = renderedTexts.titles + [renderedTexts.separators[0]] + renderedTexts.items;

    if(indexes.Length > MAX_ITEMS || renderedTexts.descriptions.Length)
      renderedTexts.merged += [renderedTexts.separators[1]];

    renderedTexts.merged += renderedTexts.descriptions;
  }

  public void MarkToRerender() {
    Log($'{EventPlayer()}: Mark to rerender');

    shouldRerender = true;
  }

  public void Render() "[MenuState] Render" {
    Log($'{EventPlayer()}: Render');

    shouldRerender = false;

    if(isOpen) {
      RenderVisibleItems();
      MergeTexts();
    } else {
      RenderClosedItems();
    }
  }

  public void RULE_Render() {
    WaitForeverUntil(shouldRerender);
    Render();
    Loop();
  }

  protected void HandleScroll() "[MenuState] Handle Scroll" {
    Log($'{EventPlayer()}: HandleScroll');

    Number idx! = history.Length - 1;
    Number offset! = 0;

    if(history.Last.innerScroll > MAX_ITEMS - 1) {
      offset = history.Last.innerScroll - (MAX_ITEMS - 1);
      history[idx] = {innerScroll: MAX_ITEMS - 1, outerScroll: history.Last.outerScroll + offset, ..history[idx]};
    } else if(history.Last.innerScroll < 0) {
      offset = history.Last.innerScroll;
      history[idx] = {innerScroll: 0, outerScroll: Max(0, history.Last.outerScroll + offset), ..history[idx]};
    }

    hoveredIndex = history.Last.innerScroll + history.Last.outerScroll;
    RenderSeparators();
  }

  public void Refresh() "[MenuState] Refresh" {
    // Log($'{EventPlayer()}: Refresh');

    history += [{ id: '<REFRESH>', innerScroll: 0, outerScroll: 0 }];
    Wait();
    DestroyPage();
    history.ModRemoveByIndex(history.Length - 1);
  }

  public virtual void GoTo(String pageId!, Boolean historyReplace! = false) "[MenuState] Go To" {
    Log($'{EventPlayer()}: GoTo');

    if(this.pageId != pageId) {
      DestroyPage();

      if(historyReplace)
        history[history.Length - 1] = HistoryItem.New(pageId);
      else
        history += HistoryItem.New(pageId);
    }
  }

  public virtual void GoBack() "[MenuState] Go Back" {
    Log($'{EventPlayer()}: GoBack');

    if(history.Length == 1) {
      if(!isPuppet) Close();
      return;
    }

    DestroyPage();
    history.ModRemoveByIndex(history.Length - 1);
  }

  public Number AddPageDescription(Description desc!) "[MenuState] Add Page Description" {
    descriptionsPage += desc;
    return descriptionsPage.Length - 1;
  }

  public Number AddMenuDescription(Description desc!) "[MenuState] Add Menu Description" {
    descriptionsMenu += desc;
    return descriptionsMenu.Length - 1;
  }

  public void RemoveMenuDescription(Number idx!) "[MenuState] Remove Page Description" {
    descriptionsMenu.ModRemoveByIndex(idx);
  }

  // TODO: STRUCT REWORK restore
  // public void WaitUntilButtonDown(in String id, in Button button) {
  //   WaitForeverUntil(onButtonDown(id, button));
  // }

  // public void WaitUntilButtonUp(in String id, in Button button) {
  //   WaitForeverUntil(!onButtonDown(id, button));
  // }

  // events
  // TODO: STRUCT REWORK restore
  // public Boolean onButtonDown(in String id, in Button button): isOpen && isFocused && hoveredItem.id == id && buttonsHeld.Contains(button);
   
  // public Boolean onEnter(in String id): isOpen && isFocused && hoveredItem.id == id;

  // public Boolean onNavigate(in String id, in Vector direction) {
  //   Vector diff = ThrottleOf(EventPlayer()) - direction * 0.5;
  //   Boolean x = AbsoluteValue(diff.X) > 0.5;
  //   Boolean y = AbsoluteValue(diff.Y) > 0.5;
  //   return isOpen && isFocused && hoveredItem.id == id && (x && !y || !x && y);
  // }
}