import '../utils/index.del';
import './menu.del';
import './helpers.del';
import './components/component.del';
import './components/text.del';
import './components/link.del';
import './components/toggle.del';
import './components/value.del';
import './components/carousel.del';
import './components/numberInput.del';
import './components/checkbox.del';
import './components/radio.del';

playervar MenuWindow[] menuWindows = [];

struct MenuWindow {
  # Maximum number of visible items.
  public static Number MAX_ITEMS: Menu.MAX_ITEMS;

  # Whether window is currently focused.
  public Boolean focused;
  # Whether window is currently open.
  public Boolean open;

  public WindowLogicActions logicActions;

  public Number index(in Number id): GetComponentIndexById(id);

  # Combination of buttons used to toggle menu on and off.
  public Button[] toggleWindowKeybind;
  # Whether opening and closing this window is done programmatically.
  public Boolean isRemotelyControlled: !toggleWindowKeybind;
  # List of available component in `menuComponents` variable used on the current page.
  public Number[] ids;
  # Index of currently focused component in `menuComponents`.
  public Number focusedId;
  # List of currently visible items.
  public Number[] visibleIds: ids.Slice(history.Last.outerScroll, MAX_ITEMS);
  # List of components that can be focused.
  public Number[] enabledIds: ids.FilteredArray((i) => !menuComponents[index(i)].disabled);
  # Currently hovered item.
  public Component focusedComponent: menuComponents[index(focusedId)];
  # History of opened pages.
  public HistoryItem[] history;
  # ID of currently open page.
  public String pageId: history.Last.id;
  # ID of root page.
  protected String rootPageId;
  # Whether menu is currently in refresh stage.
  public Boolean isRefreshing: pageId == '<REFRESH>';
  # List of additional descriptions that will be show on current page.
  public Description[] pageDescriptions;
  # List of additional descriptions that will be shown until manually removed.
  public Description[] windowDescriptions;
  # List of rendered items.
  public RenderedTexts renderedTexts;

  public static MenuWindow New(in String rootPageId, in Button[] toggleWindowKeybind): { 
    focused: false,
    open: false,
    logicActions: WindowLogicActions.New(render: true),
    toggleWindowKeybind: toggleWindowKeybind,
    ids: [],
    focusedId: 0,
    history: [HistoryItem.New(rootPageId)],
    rootPageId: rootPageId,
    pageDescriptions: [],
    windowDescriptions: [],
    renderedTexts: RenderedTexts.New(),
  };

  # Marks menu as updated.
  public ref void MarkFindClosestFocusableComponent() {
    logicActions.findClosestFocusableComponent = true;
  }

  public ref void MarkUpdateScroll() {
    logicActions.updateScroll = true;
  }

  # Marks menu to rerender.
  public ref void MarkToRerender() {
    logicActions.render = true;
  }

  public ref void MarkOnComponentEnter() {
    logicActions.componentEnter = true;
  }

  public ref void MarkOnComponentLeave() {
    logicActions.componentLeave = true;
  }

  public ref void SetTitle(in String title) {
    RenderTitle(title);
  }

  public ref void SetFocused() {
    LogHelper($'Set Focused');

    focused = true;

    // TODO: STRUCT REWORK restore
    // if(menuState != this) {
    //   menuState.isFocused = false;

    //   if(menuState.isOpen) {
    //     menuState.hoveredItem.OnLeave();
    //   }
      
    //   menuState = this;
    //   isFocused = true;

    //   if(isOpen) {
    //     hoveredItem.OnEnter();
    //   }
    // }
  }

  protected ref void OnComponentEnter(ref Component component) {
    logicActions.componentEnter = false;
    component.onEnter();
    // menuComponents[menuComponents[index].childIndex].onEnter();
  }

  protected ref void OnComponentLeave(ref Component component) {
    logicActions.componentLeave = false;
    // menuComponents[menuComponents[index].childIndex].onLeave();
    component.onLeave();
  }

  protected ref void OnComponentNavigate(ref Component component, in Vector direction) {
    component.onNavigate(direction);
    // menuComponents[menuComponents[index].childIndex].onNavigate(direction);
  }

  protected ref void OnComponentButtonDown(ref Component component, in Button button) {
    component.onButtonDown(button);
    // menuComponents[menuComponents[index].childIndex].onButtonDown(button);
  }

  protected ref void OnComponentButtonUp(ref Component component, in Button button) {
    // menuComponents[menuComponents[index].childIndex].onButtonUp(button);
    component.onButtonUp(button);
  }

  # Forcefully rerenders specified item (or currently hovered one if no `index` is specified). Call after manually adding description.
  public ref void RerenderComponent(ref Component component) {
    LogHelper($'Rerender Item');

    component.MarkToRerender();
    MarkToRerender();
  }

  # Forcefully rerenders all items.
  public ref void RerenderAllItems() {
    LogHelper($'Rerender All Items');

    for(Number i = 0; i < menuComponents.Length; i++)
      menuComponents[i].MarkToRerender();
    
    MarkToRerender();
  }

  public ref void Open() {
    LogHelper($'Open');

    if(!open) {
      open = true;

      if(focused) MarkOnComponentEnter();
      MarkToRerender();
    }
  }

  public ref void Close() {
    LogHelper($'Close');

    if(open) {
      open = false;
      
      if(focused) MarkOnComponentLeave();
      MarkToRerender();
    }
  }

  // WORKAROUND: for some reason `newPageId` must be stored, otherwise its value will be lost when passed on to HistoryItem.New
  public ref void GoToPage(in String newPageId, in Boolean historyReplace = false) {
    LogHelper('MARKED TO: Go To Page');
    logicActions.goToPage = WindowGoToPage.New(newPageId, historyReplace);
  }

  protected ref void _GoToPage(in String newPageId, in Boolean historyReplace = false) {
    LogHelper($'Go To Page: going from {pageId} to {newPageId}');

    if(pageId != newPageId) {
      DestroyPage();
      history[history.Length - (historyReplace ? 1 : 0)] = HistoryItem.New(newPageId);
    }
  }

  public ref void GoBack() {
    LogHelper($'MARKED TO: Go Back');
    logicActions.goBack = true;
  }

  protected ref void _GoBack() {
    LogHelper($'Go Back');

    if(history.Length == 1) {
      if(!isRemotelyControlled) Close();
      return;
    }

    DestroyPage();
    history.ModRemoveByIndex(history.Length - 1);
  }

  # Add items to the menu.
  public ref void AddComponents(in Number[] componentsIds, in Boolean findClosestFocusableComponent = true) {
    LogHelper($"MARKED TO: Add Components");
    logicActions.addComponents = WindowAddRemoveComponents.New(componentsIds, findClosestFocusableComponent);
  }

  protected ref void _AddComponents(in Number[] componentsIds, in Boolean findClosestFocusableComponent = true) {
    ids += componentsIds;

    LogHelper($'Add Components: Adding {componentsIds.Length} items, {ids.Length} total');

    if(findClosestFocusableComponent) {
      MarkFindClosestFocusableComponent();
    }
  }

  # Removes specified items from the menu. Will automatically clean up components in `menuComponents`.
  public ref void RemoveComponents(in Number[] componentsIds, in Boolean findClosestFocusableComponent = true) {
    LogHelper($"MARKED TO: Remove Components");
    logicActions.removeComponents = WindowAddRemoveComponents.New(componentsIds, findClosestFocusableComponent);
  }

  protected ref void _RemoveComponents(in Number[] componentsIds, in Boolean findClosestFocusableComponent = true) {
    ids -= componentsIds;
    UnregisterComponents(componentsIds);

    LogHelper($'Remove Components: Removing {componentsIds.Length} items, {ids.Length} left');
    
    if(findClosestFocusableComponent) {
      MarkFindClosestFocusableComponent();
    }
  }

  # Removes all items from the menu. Will automatically clean up components in `menuComponents`.
  public ref void RemoveAllItems(in Boolean callOnItemsChanged = true) {
    LogHelper($'Remove All Items');
    RemoveComponents(ids, callOnItemsChanged);
  }

  # Replaces all items in the menu. Will automatically clean up removed components in `menuComponents`.
  public ref void ReplaceItems(in Number[] componentsIds) {
    LogHelper($'Replace Items');

    RemoveAllItems(false);
    AddComponents(componentsIds, true);

    // TODO: STRUCT REWORK restore if perf is bad
    // RemoveItems(this.indexes - items, false);
    // AddItems(items - this.indexes, false);

    // // keep the order of passed items
    // this.indexes = items;

    // MarkFindClosestFocusableComponent();
  }

  public ref void CreatePage(in String title, in Number[] componentsIds, in Description[] descriptions = []) {
    LogHelper($'MARKED TO: Create Page with {componentsIds.Length} items');

    logicActions.createPage = WindowCreatePage.New(title, componentsIds, descriptions);
  }

  protected ref void _CreatePage(in String title, in Number[] componentsIds, in Description[] descriptions = []) {
    LogHelper($'Create Page with {componentsIds.Length} items');

    SetTitle(title);
    _AddComponents(componentsIds);

    pageDescriptions += descriptions;
    // foreach(Description desc! in descriptions)
    //   pageDescriptions += desc;

    if(open) {
      MarkOnComponentEnter();

      // `AddItems` already adds items to render queue
      MarkToRerender();
    }
  }

  public ref void DestroyPage() {
    LogHelper($'MARKED TO: Destroy Page');
    logicActions.destroyPage = true;
  }

  protected ref void _DestroyPage() {
    LogHelper($'Destroy Page');

    if(open) {
      MarkOnComponentLeave();
    }

    RemoveComponents(ids);
    // RemoveAllItems(false);

    // let's not carry over pressed button to the next page so we don't trigger button up on it
    buttonsHeld = [];
    pageDescriptions = [];
  }
  

  // phase 1: handle events
  public ref void Navigate(in Vector direction, in Boolean navigationLocked) {
    LogHelper($'Navigate: {direction}');
    Number index! = index(focusedId);

    OnComponentNavigate(menuComponents[index], direction);

    switch(focusedComponent.type) {
      case ComponentType.Carousel:
        Carousel.Navigate(menuComponents[index], direction);
        break;

      case ComponentType.NumberInput:
        NumberInput.Navigate(menuComponents[index], direction);
        break;
    }

    if(!navigationLocked && (direction == Down() || direction == Up())) {
      Number[] enabled! = enabledIds;
      if(direction == Up()) enabled = Reverse(enabled);
      
      Number enabledIndex! = enabled.Contains(focusedId) ? enabled.IndexOf(focusedId) : 0;
      Number firstEnabled: FirstOf(enabledIndex < enabled.Length - 1 ? enabled.Slice(enabledIndex + 1, MAX_ITEMS) : enabled);
      Number offset! = ids.IndexOf(firstEnabled) - ids.IndexOf(focusedId);

      if(offset != 0) {
        MarkOnComponentLeave();
        
        history[history.Length - 1].innerScroll += offset;
        MarkUpdateScroll(); 

        MarkOnComponentEnter();
      }
    }

    MarkToRerender();
  }

  public ref void ButtonDown(in Button button, in Boolean navigationLocked) {
    LogHelper($'Button Down: {button}');

    if(open) {
      Number index! = index(focusedId);
      OnComponentButtonDown(menuComponents[index], button);

      switch(focusedComponent.type) {
        case ComponentType.Link:
          if(buttonsHeld == [focusedComponent.button])
            GoToPage(focusedComponent.value);
          break;

        case ComponentType.Toggle:
        case ComponentType.Checkbox:
        case ComponentType.Radio:
          // TODO: move this to main loop so triggering SetChecked programmatically also works
          // TODO: set all components that share the same name with the same value in the main loop?
          if(focusedComponent.type == ComponentType.Radio && buttonsHeld == [focusedComponent.button]) {
            for(Number i = 0; i < ids.Length; i++) {
              Number id: ids[i];
              Number index2! = index(id);
              if(menuComponents[index2].name == focusedComponent.name && id != focusedId) {
                menuComponents[index2].SetChecked(false);
              }
            }
          }

          Toggle.ButtonDown(menuComponents[index], button);
          break;

        case ComponentType.NumberInput:
          NumberInput.ButtonDown(menuComponents[index], button);
          break;
      }

      if(!navigationLocked && buttonsHeld == [BUTTON_BACK]) {
        GoBack();
      }

      MarkToRerender();
    }
  }

  public ref void ButtonUp(in Button button, in Boolean navigationLocked) {
    LogHelper($'Button Up: {button}');

    if(open) {
      OnComponentButtonUp(menuComponents[index(focusedId)], button);
      MarkToRerender();
    }
  }

  // phase 2: rendering
  protected ref void RenderClosedItems(in Boolean hideKeybindTextWhenClosed) {
    renderedTexts.merged = 
      isRemotelyControlled || hideKeybindTextWhenClosed ? 
        [] : 
        [
          RenderedText.New(
            text: $"Press {ButtonFormatter_Underscores(toggleWindowKeybind)}​ to toggle Menu", 
            color: COLOR_NEUTRAL
          )
        ];
  }

  protected ref void RenderTitle(in String title) {
    renderedTexts.titles = [
      RenderedText.New(title, COLOR_NEUTRAL)
    ];
  }

  protected ref void RenderSeparators() {
    renderedTexts.separators = [
      RenderedText.New(
        text: $"──────────────────────{ids.Length < MAX_ITEMS ? '─' : history.Last.outerScroll == 0 ? '△' : '▲'}──────────────────────", 
        color: COLOR_NEUTRAL 
      ),
      RenderedText.New(
        text: $"──────────────────────{ids.Length < MAX_ITEMS ? '─' : history.Last.outerScroll == ids.Length - MAX_ITEMS ? '▽' : '▼'}──────────────────────",
        color: COLOR_NEUTRAL
      )
    ];
  }

  protected ref void RenderDescriptions() {
    // Description[] descriptions! = focusedComponent.descriptions;

    // if(focusedComponent.hasChild) {
    //   descriptions += menuComponents[focusedComponent.childIndex].descriptions;
    // }

    // descriptions += pageDescriptions + menuDescriptions;

    // renderedTexts.descriptions = descriptions
    //   .FilteredArray((i) => i.visible)
    //   .SortedArray((i) => i.order)
    //   .Map((i) => <RenderedText>{text: i[0], color: i[1]});

    Description[] actionDescriptions: (
      focusedComponent.actionDescriptions + 
      menuComponents[focusedComponent.childId].actionDescriptions
    ).Map((i, idx) => i ? Description.New(
      description: $"Press {ButtonFormatterSingle_Underscores(buttonsSettings[idx % 4])} to {i}", 
      order: ButtonDescriptionOrder(buttonsSettings[idx % 4])
    ) : null);

    renderedTexts.descriptions = (
      actionDescriptions +
      focusedComponent.descriptions + 
      menuComponents[focusedComponent.childId].descriptions +
      pageDescriptions + windowDescriptions
    ).FilteredArray((i) => i.visible)
      .SortedArray((i) => i.order)
      .Map((i) => RenderedText.New(text: i[0], color: i[1]));
  }

  protected String RenderComponent(in Number index, in Number childIndex) {
    Component item: menuComponents[index];

    switch(item.type) {
      case ComponentType.Component:
      case ComponentType.Text:
        return Text.Render(menuComponents[index], menuComponents[childIndex]);
      case ComponentType.Value:
        return Value.Render(menuComponents[index]);
      case ComponentType.Toggle:
        return Toggle.Render(menuComponents[index]);
      case ComponentType.Link:
        return Link.Render(menuComponents[index], menuComponents[childIndex]);
      case ComponentType.Checkbox:
        return Checkbox.Render(menuComponents[index], menuComponents[childIndex]);
      case ComponentType.Radio:
        return Radio.Render(menuComponents[index], menuComponents[childIndex]);
      case ComponentType.Carousel:
        return Carousel.Render(menuComponents[index]);
      case ComponentType.TextInput:
        return '';
      case ComponentType.NumberInput:
        return NumberInput.Render(menuComponents[index]);
    }
  }

  protected ref void RenderVisibleItems() {
    RenderDescriptions();

    Number[] v! = visibleIds;

    // LogHelper(indexes.Length);
    // LogHelper(visibleIndexes.Length);

    renderedTexts.items = [];

    for(Number idx! = 0; idx < v.Length; idx++) {
      // Number idIndex: idx + history.Last.outerScroll;
      Number id: v[idx];
      Number index! = index(id);
      Number childIndex! = index(menuComponents[index].childId);
      Component component: menuComponents[index];
      Component child: menuComponents[childIndex];

      if(component.shouldRerender || child.shouldRerender) {
        // Number[] items! = (component.hasChild ? [childIndex] : []) + [index];
        // LogHelper($"index {index} has {items.Length} items:");

        // foreach(Number idx2! in items) {
        //   // LogHelper($"item {idx2}: label - {menuComponents[idx2].label}, rendered text - {RenderComponent(idx2)}");
        //   menuComponents[idx2].renderedText = RenderComponent(idx2);
        //   menuComponents[idx2].shouldRerender = false;
        // }

        menuComponents[index].renderedText = RenderComponent(index, childIndex);
        menuComponents[index].shouldRerender = false;

        LogHelper($'Rerendered component {id} ad index {index}: {menuComponents[index].renderedText}');
      }

      renderedTexts.items[idx] = RenderedText.New( 
        text: $"{!component.disabled ? focused && focusedId == id ? '● ' : '○ ' : ''}{component.renderedText}",
        color: component.color 
      );
    }
  }

  protected ref void MergeTexts() {
    renderedTexts.merged = renderedTexts.titles + [renderedTexts.separators[0]] + renderedTexts.items;

    if(ids.Length > MAX_ITEMS || renderedTexts.descriptions.Length)
      renderedTexts.merged += [renderedTexts.separators[1]];

    renderedTexts.merged += renderedTexts.descriptions;
  }

  public ref void Render(in Boolean hideKeybindTextWhenClosed) {
    LogHelper($'Render');

    if(open) {
      RenderVisibleItems();
      MergeTexts();
    } else {
      RenderClosedItems(hideKeybindTextWhenClosed);
    }
  }






  public ref void FindClosestFocusableComponent() {
    LogHelper($'Find Closest Focusable Component');

    // TODO: STRUCT REWORK restore
    // if(!indexes) {
    //   indexes = [emptyTextIndex];
    // } else if(indexes.Length > 1 && indexes.Contains(emptyTextIndex)) {
    //   indexes -= emptyTextIndex;
    // }
    
    // `focusedIndex` is calculated later in `HandleScroll()`
    Number index! = history.Last.outerScroll + history.Last.innerScroll;
    Number id: ids[index];

    if(!ids.Contains(id) || menuComponents[index].disabled) {
      Number[] enabled! = enabledIds;
      history[history.Length - 1].innerScroll = ids.IndexOf(enabledIds.First);
    }

    MarkUpdateScroll();
  }

  public ref void UpdateScroll() {
    LogHelper($'Update Scroll');

    Number idx! = history.Length - 1;
    Number offset! = 0;

    if(history.Last.innerScroll > MAX_ITEMS - 1) {
      offset = history.Last.innerScroll - (MAX_ITEMS - 1);
      history[idx] = {
        innerScroll: MAX_ITEMS - 1, 
        outerScroll: history.Last.outerScroll + offset, ..history[idx]
      };
    } else if(history.Last.innerScroll < 0) {
      offset = history.Last.innerScroll;
      history[idx] = {
        innerScroll: 0, 
        outerScroll: Max(0, history.Last.outerScroll + offset), ..history[idx]
      };
    }

    focusedId = ids[history.Last.innerScroll + history.Last.outerScroll];
    // LogHelper($"new idx: {focusedIndex}");
    RenderSeparators();
  }


  public ref void RULE_Logic(in Boolean hideKeybindTextWhenClosed) {
    // if((<Boolean[]>logicActions).IndexOf(true) == -1)
    //   return;

    LogHelper($"========= Executing MenuWindow logic");

    if(logicActions.goBack)
      _GoBack();

    if(logicActions.goToPage)
      _GoToPage(logicActions.goToPage.pageId, logicActions.goToPage.replaceLastHistory);

    if(logicActions.destroyPage)
      _DestroyPage();

    Number index! = index(focusedId);

    if(logicActions.componentLeave)
      OnComponentLeave(menuComponents[index]);

    if(logicActions.removeComponents.indexes.Length)
      _RemoveComponents(logicActions.removeComponents.indexes, logicActions.removeComponents.updateScroll);

    if(logicActions.destroyPage)
      MinWait();

    if(logicActions.createPage.indexes.Length)
      _CreatePage(logicActions.createPage.title, logicActions.createPage.indexes, logicActions.createPage.descriptions);

    if(logicActions.addComponents.indexes.Length)
      _AddComponents(logicActions.addComponents.indexes, logicActions.addComponents.updateScroll);

    if(logicActions.findClosestFocusableComponent)
      FindClosestFocusableComponent();

    if(logicActions.updateScroll)
      UpdateScroll();

    index = index(focusedId);

    if(logicActions.componentEnter)
      OnComponentEnter(menuComponents[index]);

    if(logicActions.render)
      Render(hideKeybindTextWhenClosed);

    logicActions = WindowLogicActions.New();

    LogHelper($"========= Finished Executing MenuWindow logic");    
  }
}