// import '../menuState.del';
import '../../utils/string.formatters.del';
import '../../utils/index.del';
import '../customButtons.del';



single struct Description {
  public String text;
  public Color color;
  public Boolean visible;
  public Number order;

  public static Description New(in String description, in Color color = COLOR_NEUTRAL, in Boolean visible = true, in Number order = 0): 
    {text: description, color: color, visible: visible, order: order};

  public static Description BASE: {
    text: '',
    color: COLOR_NEUTRAL,
    visible: true,
    order: 0
  };
}

enum ComponentType {
  Text,
  Value,
  Link,
  Toggle,
  Checkbox,
  Radio,
  Carousel,
  TextInput,
  NumberInput
}

single struct InputSettings {
  public Number min;
  public Number max;
  public Boolean negative;
  public Number integralLength;
  public Number fractionalLength;
  public Number length;
  public String unit;

  public static InputSettings New(): {
    min: NUMBER_MIN,
    max: NUMBER_MAX,
    negative: false,
    integralLength: 5,
    fractionalLength: 3,
    length: NUMBER_MAX,
    unit: ''
  };
}

struct Component {
  # Type of the component 
  public ComponentType type;
  # Displayed label
  public String label;
  # Name under which the value of the component is stored
  public String name;
  # Value stored in the component
  # 
  # Usable by:
  # - `Value` - stores displayed value
  # - `Link` - stores Page ID that should be opened when interacted
  # - `Toggle`, `Radio`, `Checkbox` - stores Component's current state
  # - `Carousel` - stores currently selected option
  # - `TextInput`, `NumberInput` - stores merged `parts`
  public Any value;
  # Function to retrieve default value
  public (() => Any) defaultValue;
  # Available options
  # 
  # Usable by:
  # - `Carousel`
  public Any[] options;
  # Index of the currently selected option
  # 
  # Usable by:
  # - `Carousel`
  # - `TextInput`, `NumberInput`
  protected Number index;
  # Value split into parts
  # 
  # Usable by:
  # - `TextInput`, `NumberInput` - user's provided value in edit mode
  public Number[] parts;
  # Formatter that generates nicely formatted String from a `value`
  public ((Any) => String) valueFormatter;
  # Descriptions assigned to the component
  public Description[] descriptions;
  # Color of the displayed text
  public Color color;
  # Whether component is disabled
  public Boolean disabled;
  # Stores settings required for `NumberInput` and `TextInput`
  public InputSettings inputSettings;
  # Whether the component captures all navigation inputs from the menu
  # 
  # Usable by:
  # - `TextInput`, `NumberInput`
  public Boolean captureNavigationInputs;
  # Button which triggers Component's built-in functionality
  # 
  # Usable by:
  # - `Link` - button that opens a page
  # - `Toggle`, `Radio`, `Checkbox` - button that toggles component's state
  # - `TextInput`, `NumberInput` - button that toggles edit mode
  public Button button;
  # Whether the component should rerender during next rendering phase
  public Boolean shouldRerender;
  # Fully rendered text
  public String renderedText;
  # Child component
  public Component child: <Component>_child;

  // public static ((Any) => String) VALUE_FORMATTER: (value) => value;

  // # Parent `MenuState`
  // public MenuState menuState;
  // # Unique identifier of the component
  // public Number id;
  
  private Any _child;
  
  // public (() => void) onRender;
  // public (() => void) onEnter;
  // public (() => void) onLeave;
  // public ((Button) => void) onButtonDown;
  // public ((Button) => void) onButtonUp;
  // public ((Vector) => void) onNavigate;
  public ((Any) => void)[] actions;

  public static Component New(
    in ComponentType type,
    in String label,
    in Component child = <Component>null
  ) : {
    type: type,
    name: null, 
    value: null, 
    defaultValue: null, 
    valueFormatter: null, 
    options: [],
    index: 0,
    parts: [],
    label: label, 
    descriptions: [], 
    color: COLOR_NEUTRAL, 
    disabled: false, 
    inputSettings: InputSettings.New(), 
    captureNavigationInputs: false, 
    button: BUTTON_PRIMARY, 
    renderedText: '', 
    shouldRerender: true,
    _child: <Any>child, 

    // id: null, 
    // menuState: null, 

    // onRender: null,
    // onEnter: null,
    // onLeave: null,
    // onButtonDown: null,
    // onButtonUp: null,
    // onNavigate: null,
    actions: []
  };

  
  public ref void AddDescription(in Description description) {
    descriptions += description;
  }

  public ref void MarkToRerender() {
    shouldRerender = true;
  }

  public ref void SetPrimaryAction(in String description, in () => void action) {
    actions[0] = action;
    AddDescription(Description.New($"Press {ButtonFormatterSingle_Underscores(BUTTON_PRIMARY)}​ to {description}", order: ButtonDescriptionOrder(BUTTON_PRIMARY)));
  }

  public ref void SetSecondaryAction(in String description, in () => void action) {
    actions[1] = action;
    AddDescription(Description.New($"Press {ButtonFormatterSingle_Underscores(BUTTON_SECONDARY)}​ to {description}", order: ButtonDescriptionOrder(BUTTON_SECONDARY)));
  }

  public ref void SetTertiaryAction(in String description, in () => void action) {
    actions[2] = action;
    AddDescription(Description.New($"Press {ButtonFormatterSingle_Underscores(BUTTON_TERTIARY)}​ to {description}", order: ButtonDescriptionOrder(BUTTON_TERTIARY)));
  }

  public ref void SetQuaternaryAction(in String description, in () => void action) {
    actions[3] = action;
    AddDescription(Description.New($"Press {ButtonFormatterSingle_Underscores(BUTTON_QUATERNARY)}​ to {description}", order: ButtonDescriptionOrder(BUTTON_QUATERNARY)));
  }

  // public virtual void HandleActions() "[Component] Handle Action" {
  //   if(buttonsHeld == [BUTTON_PRIMARY]) onPrimaryAction(this);
  //   else if(buttonsHeld == [BUTTON_SECONDARY]) onSecondaryAction(this);
  //   else if(buttonsHeld == [BUTTON_TERTIARY]) onTertiaryAction(this);
  //   else if(buttonsHeld == [BUTTON_QUATERNARY]) onQuaternaryAction(this);
  // }

  // // idk why OSTW thinks using child's `Render()` method makes it recursive
  // public virtual void Render() "[Component] Render" {
  //   onRender(this);
  //   renderedText = child.renderedText || label;
  // }

  // // events
  // public virtual void OnEnter() "[Component] OnEnter" {
  //   onEnter(this);

  //   if(child)
  //     child.OnEnter();
  // }

  // public virtual void OnLeave() "[Component] OnLeave" {
  //   onLeave(this);

  //   if(child)
  //     child.OnLeave();
  // }
  
  // public virtual void OnButtonDown(Button button!) "[Component] OnButtonDown" {
  //   onButtonDown(button, this);

  //   HandleActions();
    
  //   if(child)
  //     child.OnButtonDown(button);
  // }

  // public virtual void OnButtonUp(Button button!) "[Component] OnButtonUp" {
  //   onButtonUp(button, this);

  //   if(child)
  //     child.OnButtonUp(button);
  // }

  // public virtual void OnNavigate(Vector direction!) "[Component] OnNavigate" {
  //   onNavigate(direction, this);

  //   if(child)
  //     child.OnNavigate(direction);
  // }
}

playervar Component[] test = [
  Component.New(ComponentType.Text, 'Test'),
  Component.New(ComponentType.Text, 'Test'),
  Component.New(ComponentType.Text, 'Test'),
  Component.New(ComponentType.Text, 'Test'),
  Component.New(ComponentType.Text, 'Test'),
  Component.New(ComponentType.Text, 'Test')
];

rule: 'My Player Rule'
Event.OngoingPlayer
Team.All
Player.All
{
  test[0].AddDescription(Description.New("aaaaa", COLOR_ERROR, true, 0));
  test[0].SetPrimaryAction("bbbbb", () => Kill(HostPlayer()));
  test[0].SetSecondaryAction("ccccc", () => Teleport(HostPlayer()));

  test[0].MarkToRerender();
}

rule: 'My Player Rule'
Event.OngoingPlayer
Team.All
Player.All
{
  Wait(5);
  (test[0].actions[0])('t');
}