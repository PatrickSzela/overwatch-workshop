struct BigArray<T> {
  static public Number MAX_ARRAY_SIZE: 1000;
  public T[][] multiArray;
  public Number Length;

  private Number FirstIdx(in Number idx): RoundToInteger(idx / MAX_ARRAY_SIZE, Rounding.Down);
  private Number SecondIdx(in Number idx): idx % MAX_ARRAY_SIZE;
  
  public constructor(in T[] arr) {
    multiArray = [arr];
    Length = arr.Length;
  }

  public T Get(in Number idx): multiArray[FirstIdx(idx)][SecondIdx(idx)];

  private void Set(ref BigArray<T> array, in Number idx, in T value) {
    array.multiArray[FirstIdx(idx)][SecondIdx(idx)] = value;
  }

  private void RecalculateLength(ref BigArray<T> array) {
    array.Length = 0;
    foreach (T[] i in array.multiArray)
      array.Length += i.Length;
  }

  public void Clear(ref BigArray<T> array) {
    array.multiArray = [];
    array.Length = 0;
  }

  public T First(): multiArray[0][0];

  public T Last(): Get(Length - 1);

  public void Append(ref BigArray<T> array, in T value) { 
    Set(array, array.Length, value); 
    array.Length++;
  }

  public void Concat(ref BigArray<T> array, in T[] value) {
    Number count! = Length;

    if(!multiArray[FirstIdx(count)].Length) {
      array.multiArray[FirstIdx(count)] = [];
    }

    Number availableSpace! = MAX_ARRAY_SIZE - multiArray[FirstIdx(count)].Length;

    T[][] split = [value.Slice(0, availableSpace), value.Length > availableSpace ? value.Slice(availableSpace, value.Length - availableSpace) : []];

    if(value.Length >= availableSpace) {
      array.multiArray[FirstIdx(count)] += split[0].Slice(0, split[0].Length - 1);
      // workaround for broken Append() when resulting array would end up having 1000 elements
      array.multiArray[FirstIdx(count)][multiArray[FirstIdx(count)].Length] = split[0].Last;    
    } else {
      array.multiArray[FirstIdx(count)] += split[0];
    }

    if(split[1].Length) array.multiArray[FirstIdx(count) + 1] = split[1];

    RecalculateLength(array);
  }

  public void ConcatBigArray(ref BigArray<T> array, in BigArray<T> value) {
    foreach(T[] arr in value.multiArray) {
      array.Concat(array, arr);
    }
  }

  public static BigArray<T> Reverse(ref BigArray<T> array) {
    T[][] copy = array.multiArray.SortedArray((_, idx) => -idx);

    for(Number i! = 0; i < copy.Length; i++) {
      copy[i] = copy[i].SortedArray((_, idx) => -idx);
    }

    BigArray<T> arr = { multiArray: copy, Length: 0 };
    arr.RecalculateLength(arr);
    return arr;
  }

  public Boolean Contains(in T value) {
    return multiArray.IsTrueForAny((t) => t.Contains(value));
  }
}